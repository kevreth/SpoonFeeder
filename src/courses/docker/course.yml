---
name: Docker
units:
- name: Introduction
  lessons:
  - name: Introduction
    modules:
    - name: Basic Docker concepts
      inst:
      - type: info
        txt: |
          A _container_ is a sandboxed process running on a host machine.

          _Sandboxed_ means the has no access to or awareness of the host or other sandboxed processes.
      - type: bool
        txt: A sandboxed process can identify the operating system version of it's host.
        ans: 'no'
        exp: A sandboxed process has no knowledge of it's host.
      - type: info
        txt: |
          Docker is software that _containerizes_ applications.

          _Applications_ may include databases, Web servers, or even entire operating systems.

          In lieu of installing the application on the host machine, a Docker _container_ can be installed instead. Containers are easily added and removed. Most importantly, several instances can execute simultaneosly, even of different versions. So for example, Python 2 and Python 3 (Python is a programming language) containers can execute simultaneously. They're unaware of each other.
      - type: bool
        txt: With Docker, two copies of PostgreSQL 11 and three copies of PostgreSQL 12 (PostgreSQL is a database management server) could operate simultaneously.
        ans: 'yes'
        exp: A container allows multiple copies of multiple versions of applications to execute at the same time. They are unaware of each other.
      - type: bool
        txt: Docker cannot containerize operating systems.
        ans: 'no'
        exp: Docker can fully containerize operating systems.
      - type: info
        txt: |
          An _image_ is a filesystem (a set of computer disk folders and files) and a set of instructions containing everything required to execute an application in a container.

          Think of an image as a pattern and a container as a realization of that pattern. A container is an executable instance of an image. An image cannot be executed. It must be built (not just copied) into a container first.
      - type: bool
        txt: An image is simply copied to a container.
        ans: 'no'
        exp: An image must be built into a container.
      - type: bool
        txt: Docker executes images
        ans: 'no'
        exp: Docker executes containers that are built from images.
      - type: bool
        txt: An image contains a filesystem and build instructions.
        ans: 'yes'
        exp:
      - type: info
        txt: |
          Summary

          sandboxed: when an application cannot know about or affect its host environment
          container: a sandboxed process running on a host machine
          Docker: software that containerizes applications
          image: a filesystem and build instructions containing everything required to execute in a container

          Docker enables multiple copies of multiple versions of applications to execute simulataneously.
      - exercises:
        - type: gap
          txt: (1) will build a(n) (2) into to a(n) (3) that is in a(n) (4) on the host machine.
          ans:
          - Docker
          - image
          - container
          - sandbox
        - type: vocab
        - list:
            Docker: software that containerizes applications
            image: a filesystem and build instructions containing everything required to execute in a container
            container: a sandboxed process running on a host machine
            sandbox: an application cannot know about or affect its host environment
    - name: Microservices
      - type: info
        txt: |
          The primary use case for Docker is operating _microservices_. For example, instead of one copy of the Apache Web server executing, several copies, each in a container, execute simultaneously. The redundancy enables failed copies of Apache to gracefully degrade capacity. If there was only one copy executing and it failed then the site would be offline. Microservices provide fault tolerance through redundancy.
      - type: bool
        txt: The primary benefit of microservices is ease of administration.
        ans: 'no'
        exp: The primary benefit of microservices is fault tolerance.
      - type: bool
        txt: The primary use case for Docker is operating _microservices_.
        ans: 'yes'
        exp:
      - type: info
        txt: |
          _Microservices_ have their name because each container should be as small as possible. A set of database management microservices may exist where each microservice only serves part of the data required for a composite service or application. Each of those microservices (which corresponds to an _image_) would operate redundantly across many containers.
      - type: bool
        txt: A microservice container should be as small as possible.
        ans: 'yes'
        exp:
      # - type: bool
      #   txt:
      #   ans: 'yes'
      #   exp:
      - type: info
        txt: |
          Summary

          * The primary use case for Docker is operating _microservices_.
          * Microservices provide fault tolerance through redundancy.
          * A microservice container should be as small as possible.
      exercises:
      - type: gap
        txt: A (1) provides (2) through (3).
        ans:
          - microservice
          - fault tolerance
          - redundancy
    - name: Working with images and containers
      - type: info
        txt: |
          image::docker.basic.svg[Static,300]

          The Docker client commands and receives responses from the Docker server.

          The Docker server interacts with images and containers.

          An Image may be deployed to multiple containers.

          A container can only contain one image.
      - type: info
        txt: |
          The Docker client is invoked with `docker` at a command prompt (such as PowerShell, Bash, ZShell, or the Windows Command Prompt) followed by a Docker command. For example, typing

          `docker version`

          at a command prompt informs if both the client and server are running.

          [literal]
          ----
          $ docker version
          Client: Docker Engine - Community
          Version:           25.0.0
          API version:       1.44
          Go version:        go1.21.6
          (etc.)

          Server: Docker Engine - Community
          Engine:
            Version:          25.0.0
            API version:      1.44 (minimum version 1.24)
          (etc.)
          ----
      - type: info
        txt: |
          Obtaining images
    - name: Interacting with Images

    - name: Deploying an image
      inst:
      - type: info
        txt: |
          Deploying an image

          - obtain an image
          - create a Dockerfile
          - build the image
          - run the image
          - see the results
      - type: info
        txt: |
          Obtain an image

          In general, there's three ways to obtain images:
          - create and build it yourself
          - clone a repository and build the image
          - download prebuilt images
          Clone the repository
          git clone https://github.com/docker/getting-started-app.git

          #after clone, cd into the new directory
          cd getting-started-app
        type: inst
        txt: |
          Create the Dockerfile

          echo '
          # syntax=docker/dockerfile:1

          FROM node:18-alpine
          WORKDIR /app
          COPY . .
          RUN yarn install --production
          CMD ["node", "src/index.js"]
          EXPOSE 3000' > Dockerfile
        type: inst
        txt: |
          # build the image
          docker build -t getting-started-app .

          # run the image
          docker run --name getting-started-app -dp 127.0.0.1:3000:3000 getting-started-app
        type: inst
        txt: |
          #see the image in operation
          docker ps -a
          docker images

          #see the result
          xdg-open http://localhost:3000
        type: inst
        txt: |
          docker build: creates an image
          docker run: starts a container
          docker ps: lists containers
          docker images: lists images
          docker compose: ''
      exercises:
      - type: sort
        txt: list in the order needed to execute them when deploying an image
        ans:
          - git clone
          - create Dockerfile
          - docker build
          - docker run
          - docker ps
    - name: Removing an image
      inst:
      - type: int
        txt: |
          docker rm: deletes container
          docker rmi: deletes image
          docker stop: halts container execution
    - name: Review
      exercises:
      - type: vocab
        list:
          docker:
          container: a sandboxed process running on a host machine that is isolated from all other processes running on that host machine
          image: a filesystem containing everything required to execute in a container
          dockerfile: a script to build a container image
          docker build: creates an image
          docker run: starts a container
          docker ps: lists containers
          docker images: lists images
          docker rm: deletes container
          docker rmi: deletes image
          docker stop: halts container execution
   - name: Containerizing an app
  - name: Development containers
  - name: The Dockerfile
   lessons:
    - name: Instruction Overview
      modules:
      - name: Instruction Overview
        inst:
        txt: |
          ADD
          ARG
          CMD
          COPY
          ENTRYPOINT
          ENV
          EXPOSE
          FROM
          HEALTHCHECK
          LABEL
          MAINTAINER
          ONBUILD
          RUN
          SHELL
          STOPSIGNAL
          USER
          VOLUME
          WORKDIR
        inst:
        txt: |
          ADD:: Add local or remote files and directories.
          ARG:: Use build-time variables.
          CMD:: Specify default commands.
          COPY:: Copy files and directories.
          ENTRYPOINT:: Specify default executable.
          ENV:: Set environment variables.
          EXPOSE:: Describe which ports your application is listening on.
          FROM:: Create a new build stage from a base image.
          HEALTHCHECK:: Check a container's health on startup.
          LABEL:: Add metadata to an image.
          MAINTAINER:: Specify the author of an image.
          ONBUILD:: Specify instructions for when the image is used in a build.
          RUN:: Execute build commands.
          SHELL:: Set the default shell of an image.
          STOPSIGNAL:: Specify the system call signal for exiting a container.
          USER:: Set user and group ID.
          VOLUME:: Create volume mounts.
          WORKDIR:: Change working directory.
  - name: Docker Commands
