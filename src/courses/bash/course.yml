name: Bash
txt: null
units:
  - name: Basic Bash
    txt: null
    lessons:
    - name: Introduction
      txt: null
      modules:
      - name: asdf
        txt: null
        inst:
        - type: info
          name: What is Bash?
          sdbr: null
          ref: null
          txt: |
            _Bash_ is a _command line interface_ (CLI) to Linux and many other operating systems. Unless a _graphical user interface_ (GUI) is started with lots of pretty windows that move around, Bash will probably be what is seen after logging into a Linux computer. So, after entering a correct username and password, what will be seen is something like this with no indication of what to do next.

            `$_`

            If a GUI is started, then Bash can be started in a window of the GUI but the specific method varies among Linux systems.

            Bash vs. a GUI

            ++++
            <style>
            .flex-container {
              display: flex;
              justify-content: space-around;
              align-items: flex-start;
            }
            .flex-item {
              flex: 1;
              margin: 0; /* Eliminate default margins */
              display: flex;
              flex-direction: column;
            }
            .source-code, .image-container {
              padding: 0px; /* Reduced padding */
              flex: 1;
              display: flex;
              justify-content: center; /* Center content for visual appeal */
              align-items: center; /* This might need adjustment based on your content */
            }
            /* Optional: Reduce bottom margin on preformatted blocks */
            pre {
              margin-bottom: 0;
            }
            </style>
            <div style="display: flex; justify-content: left; align-items: flex-start;">
            <div style="flex: 1; padding: 0px;">
            ++++

            [source,bash]
            ----
            $ pwd
            /home/user
            $ ls
            Documents  Downloads  Music  Pictures  Projects
            $ cd Projects
            $ ls
            my_project
            $ cd my_project
            $ ls
            data.txt  notes.txt  script.sh
            $ cat notes.txt
            Meeting notes:
            - Discuss project timeline
            - Review initial requirements
            $ grep "timeline" notes.txt
            - Discuss project timeline
            $ echo "TODO: Add more data analysis steps" >> notes.txt
            ----

            ++++
            </div>
            <div style="flex: 1; padding: 10px;">
            ++++

            image::gui.svg[GUI example,opts="inline"]

            ++++
            </div>
            </div>
            ++++
          ccq: null
        - type: info
          name: Why use Bash?
          sdbr: null
          ref: null
          txt: |
            One may wonder why a CLI like Bash is worth learning when an easy learned and used GUI is available. The answer is,

            * CLIs make certain types of tasks easier
            * Some tasks cannot be done without Bash because a GUI equivalent is unavailable.
            * Tasks can easily be automated with Bash but GUI automation is difficult.
            * Typing is faster than using the mouse for most tasks.

            Examples of these situations will be demonstrated through the course.

            A distinguishing trait of advanced Linux users is knowing how to use Bash.
          ccq: null
    - name: The Linux filesystem
      txt: null
      modules:
      - name: Filesystem objects
        txt:  null
        inst:
        - type: info
          name: Directories, files, and data
          sdbr: null
          ref: null
          txt: |
            Although not specific to Bash, understanding how Linux stores data is necessary to use Bash.

            A _filesystem_ is how computers store data on permanent storage devices such as disk drives. Filesystems contain primarily two types of items, known as _objects_: _directories_ and _files_.

            _Files_ contain data. A file can contain any type of computer data. Examples include a text document, a music track, or software program. Files cannot contain other files.

            _Directories_ are an organization tool. Directories contain files and other directories but cannot directly contain data like files can.

            The relationship of directories, files, and data. Arrows represent containership.

            [graphviz, format="svg"]
            ....
            digraph g {
              files -> data
              directories -> files
              directories -> directories
            }
            ....
          ccq: null
        - type: info
          name: Filesystems
          sdbr: null
          ref: null
          txt: |
            Comparing a filesystem to a tree, directories are tree branches and files are leaves. Leaves (files) can grow anywhere, including the tree trunk.

            At the top of the tree is the _root directory_ which corresponds to a tree trunk. There can be only one root directory and it is named "/", which is the character _frontslash_ ("\" is a "backslash").

            An example filesystem. Arrows represent containership.

            [graphviz, format="svg"]
            ....
            digraph g {
              "/" -> dir1
              "/" -> dir2
              "/" -> file1
              "/" -> file2
              dir1 -> file4
              dir1 -> file5
              dir1 -> dir4 -> file9
              dir1 -> dir5 -> file10
              dir2 -> dir6 -> file11
              dir2 -> dir7 -> file12
              dir2 -> file8
            }
            ....

            In this simple filesystem, the root directory contains two directories and two files.
            Each of those two directories also contain directories and files.
            There is no practical limit to the number of directories and files a directory can contain,
            nor is there a practical limit to how deep directories can branch to other directories.

        - type: info
          name: Filesystem object naming
          sdbr: null
          ref: null
          txt: |
            null
            Each filesystem object has a name associated with it.

            [graphviz, format="svg"]
            ....
            digraph g {
              "/" -> bob
              "/" -> sue
              "/" -> "annual.report.q1.txt"
              "/" -> "annual.report.q2.txt"
              bob -> "holiday.party.txt"
              bob -> "corporate.retreat.mp4"
              sue -> "accounts.payable.txt"
            }
            ....

            In this example, the root directory contains directories for "bob" and "sue" and two files. "bob" contains two files and "sue" contains one file.
          ccq: null
      - name: File paths
        txt: |
          null
        inst:
        - type: info
          name: Filesystem paths
          sdbr: null
          ref: null
          txt: |
            We can address any object on a filesystem using a _path_.

            [graphviz, format="svg"]
            ....
            digraph g {
              "/" [style=filled, fillcolor=lightblue]
              bob [style=filled, fillcolor=lightblue]
              "holiday.party.txt" [style=filled, fillcolor=lightblue]
              "/" -> bob
              "/" -> sue
              "/" -> "annual.report.q1.txt"
              "/" -> "annual.report.q2.txt"
              bob -> "holiday.party.txt"
              bob -> "corporate.retreat.mp4"
              sue -> "accounts.payable.txt"
            }
            ....

            The directories necessary to address any file or directory in a file path are separated by "/".

            The path to "holiday.party.txt" is "/bob/holiday.party.txt".

            Every object on the filesystem can be addressed this way.
          ccq: null

        - type: info
          name: A different view of directory contents
          sdbr: null
          ref: null
          txt: |
            Up to now, directory contents have been presented graphically:

            [graphviz, format="svg"]
            ....
            digraph g {
              "/" -> bob
              "/" -> sue
              "/" -> amy
              "/" -> "annual.report.q1.txt"
              bob -> "holiday.party.txt"
              sue -> "accounts.payable.txt"
            }
            ....

            From now on, directory contents will be presented textually,
            which is how you would see them when using Bash.
            The root directory is omitted.

            [source]
            ----
            annual.report.q1.txt
            annual.report.q2.txt
            bob
              holiday.party.txt
            sue
              accounts.payable.txt
            amy/
            ----

            `amy` is an empty directory that contains no objects.
            To distinguish empty directories from files, empty directories have a frontslash after them.

            This can refer to any directory contents, not just the root directory.
            For example, this listing could be the contents of `/human.resources/employees/`
          ccq: null
        - type: info
          name: 'File paths: ending frontslashes'
          sdbr: null
          ref: null
          txt: |
            An ending "/" distinguishes if the final item in a directory path is a file or a directory. So,

            `monthly.reports/` is a directory

            `monthly.reports` is a file.

            The ending frontslash is often omitted depending on situations which we will explore.
          ccq: null
        - type: info
          name: 'File paths: file extensions'
          sdbr: null
          ref: null
          txt: |
            By convention, a file ends with a short identifier,
            called a _file extension_ indicating the type of file, but it's not a requirement.

            `annual.report.q1.txt` is a text file.

            `corporate.retreat.mp4` is an mp4 video file.

            Hundreds of standard file extensions exist. You will learn more file extensions as you learn Bash.
          ccq: null
        - type: info
          name: Directory contents must have unique names
          sdbr: null
          ref: null
          txt: |
            Within a single directory, no two objects can have the same name.
            So within `/bob/` there cannot be any file or directory with the same name as another file or directory in `/bob/`.
            Two objects in the filesystem may be named identically but they must be in different directories.

            This cannot occur.

            [source, bash]
            ----
            /bob/test.txt
            /bob/test.txt
            ----

            However this is fine.

            [source, bash]
            ----
            /bob/test.txt
            /sue/test.txt
            ----

            Beyond their role in organization, directories prevent name conflicts.
          ccq: null
    - name: Beginning Bash
      txt: null
      modules:
      - name: The Bash interface
        txt: |
          null
        inst:
        - type: info
          name: Current working directories
          sdbr: null
          ref: null
          txt: |
            Every Bash session has an associated _current working directory_ (CWD).
            Think of the CWD as your current location on the filesystem.

            [source, bash]
            ----
            annual.report.q1.txt
            annual.report.q2.txt
            bob
              holiday.party.txt
              corporate.retreat.mp4
            sue
              accounts.payable.txt
            ----

            The contents of the CWD can be addressed without using complete file paths.
            If our CWD is "bob" then we can address "holiday.party.txt" without preceding with "/bob/".
          ccq: null
        - type: info
          name: Home directories
          sdbr: null
          ref: null
          txt: |
            When starting Bash, your CWD is normally the _home directory_ of the user you logged in as.
            Unless configured otherwise, the home directory follows the pattern

            `/home/<username>`

            So if you are logged in under "bob", your home directory, and where Bash starts, will be

            `/home/bob/`
          ccq: null
        - type: info
          name: Bash interface
          sdbr: null
          ref: null
          txt: |
            The most common way to interact with Bash is by typing _commands_.

            Typically the Bash interface looks something like this (although it can be configured to look much different)

            `$`

            That is called the _prompt_ and where commands can be typed in.
            The prompt is automatically displayed immediately after initiating a Bash session.
          ccq: null
        - type: info
          name: 'Printing to the screen: `echo`'
          sdbr: null
          ref: null
          txt: |
            Our first Bash command will simply print something to the screen.
            Anything after the prompt (`$`) is content you would type.

            [source, bash]
            ----
            $ echo "Hello World!"
            Hello World!
            ----

            Always press the `ENTER` (or on some systems `RETURN`) key after finishing typing a command to execute it.
            `echo`: display a line of text
          ccq: null
      - name: The current working directory
        txt: |
          null
        inst:
        - type: info
          name: Displaying the CWD
          sdbr: null
          ref: null
          txt: |
            From now on, many slides will display a listing of CWD at the beginning. For example,

            [source, bash]
            ----
            annual.report.q1.txt
            annual.report.q2.txt
            bob
              holiday.party.txt
              corporate.retreat.mp4
            sue
              accounts.payable.txt
            ----

            will be provided without identification.

            Just know that's the tree of the CWD you're working with.
            In most cases, the CWD will only be identified if significant..
          ccq: null
        - type: info
          name: 'Printing the path of the CWD: `pwd`'
          sdbr: null
          ref: null
          txt: |
            If the CWD is `/home/bob/`, then

            [source, bash]
            ----
            $ pwd
            /home/bob
            ----
          ccq: null
        - type: info
          name: 'changing the CWD: `cd`'
          sdbr: null
          ref: null
          txt: |
            [source, bash]
            ----
            bob/
            ----

            [source, bash]
            ----
            $ cd bob
            $ pwd
            bob
            ----
          ccq: null
      - name: Creating and viewing file objects
        txt: |
          null
        inst:
        - type: info
          name: 'Listing directory contents: `ls`'
          sdbr: null
          ref: null
          txt: |
            [source, bash]
            ----
            corporate.retreat.mp4
            holiday.party.txt
            ----

            [source, bash]
            ----
            $ ls
            corporate.retreat.mp4 holiday.party.txt
            ----

            `ls` by itself does not provide any indication of what the type of the objects are.
            We will see later how to fix that.
          ccq: null
        - type: info
          name: 'Creating a new directory: `mkdir`'
          sdbr: null
          ref: null
          txt: |
            [source, bash]
            ----
            bob/
            ----

            [source, bash]
            ----
            $ mkdir sue
            $ ls
            bob sue
            ----
          ccq: null
        - type: info
          name: 'Creating a file: `>`'
          sdbr: null
          ref: null
          txt: |
            Bash features _output redirection_ to send the output of a command to a file.
            The pattern of redirection is *always*

            <command> <redirection operator> <file>

            Earlier we used the `echo` command to print a message to the screen.
            This time we will use output redirection to instead create a file to contain the output of `echo`.

            Here, the _output redirector_ `>` is used to create a new file and add content to it.

            [source, bash]
            ----
            $ echo "this is a line" > test.txt
            $ ls
            test.txt
            ----
          ccq: null
        - type: info
          name: 'Viewing file contents: `cat`'
          sdbr: null
          ref: null
          txt: |
            [source, bash]
            ----
            $ echo "this is a line" > test.txt
            $ cat test.txt
            this is a line
            ----
          ccq: null
        - type: info
          name: 'Adding more lines: `>>`'
          sdbr: null
          ref: null
          txt: |
            The redirector used earlier `>`, always overwrites any existing file content.

            [source, bash]
            ----
            $ echo "this is a line" > test.txt
            $ cat test.txt
            this is a line
            $ echo "this is a different line" > test.txt
            $ cat test.txt
            this is a different line
            ----

            "this is a line" was overwritten.

            Instead of overwriting, add a second line using the _append redirector_ (`>>`).

            [source, bash]
            ----
            $ echo "second line" >> test.txt
            $ cat test.txt
            first line
            second line
            ----

            Like the output redirector,
            the file will be created if it doesn't exist,
            so to prevent data loss,
            we will usually prefer append redirection to output redirection.
          ccq: null
      - name: Copying, renaming, and moving files
        txt: |
          null
        inst:
        - type: info
          name: 'Copying files: `cp`'
          sdbr: null
          ref: null
          txt: |
            `cp` copies filesystem objects.

            [source, bash]
            ----
            $ cp test.txt sample.txt
            $ ls
            test.txt sample.txt
            ----

            `cp` cannot copy directories this way. We will look at directory copying later.
          ccq: null
        - type: info
          name: 'Renaming files: `mv`'
          sdbr: null
          ref: null
          txt: |
            `mv` renames and moves filesystem objects.

            [source, bash]
            ----
            $ mkdir /home/bob/
            $ echo "first line" > test.txt
            $ mv test.txt test0.txt
            test.txt test0.txt
            ----

            `mv` is an abbreviation of "move". Why "move" instead of "rename"?

            Think of `mv` as using the entire file path:

            `/home/bob/test0.txt`

            The data was previously available at

            `/home/bob/test.txt`

            So, test.txt was renamed by moving it to another path.

            We are not moving data, but rather moving the data to another path.
          ccq: null
        - type: info
          name: 'Moving files: `mv`'
          sdbr: null
          ref: null
          txt: |
            If we want to move the file to the home directory we can use `mv` also

            [source, bash]
            ----
            $ mkdir /home/bob/
            $ echo "first line" > test.txt
            $ mv test.txt /home/
            $ ls /home/
            test.txt
            ----

            With `mv`, we're changing the path to a file or directory; "moving to a new address".
          ccq: null
    - name: Command arguments
      txt: |
        null
      modules:
      - name: sad
        txt: |
          null
        inst:
        - type: info
          name: The many meanings of "command"
          sdbr: null
          ref: null
          txt: |
            The use of "command" has been used in different ways.

            * A command as in `echo` (a basic command)
            * A command as in `echo test.txt` (a command with arguments)
            * A command as in `echo test.txr > test.txt` (everything typed before pressing ENTER)

            All three of these are correct.
            While it may seem a problem, in practice which of the three meanings of "command" is intended is understood from context.
          ccq: null
        - type: info
          name: Arguments we've already seen
          sdbr: null
          ref: null
          txt: |
            We've seen several cases where a command was used with some additional information (which together is also a command):

            * `cd bash-tutorial`
            * `cp test.txt sample.txt`
            * `echo "this is a line"`
            * `mkdir /home/bob/`
            * `mv test.txt test0.txt`

            Instances of that additional information are called _arguments_.
            The arguments we've seen so far are _positional arguments_ and are the simplest type of arguments.
            The meanings of positional arguments are understood based on their location in the arguments. For example, with `mv`,

            `mv test.txt test0.txt`

            the first positional argument is always the existing file object and the second positional argument is always the new location.
            They cannot be reversed.

            Redirectors (`>`, `>>`) are not arguments.
          ccq: null
      - name: Options
        txt: |
          null
        inst:
        - type: info
          name: Option example
          sdbr: null
          ref: null
          txt: |
            An _option_ is an argument of one letter preceded by a dash "-".
            An example of using an option is `-1` used with `ls`.
            `-1` (one-column) instructs `ls` to list directory contents vertically instead of horizontally.

            [source,bash]
            ----
            company_brand_book.pdf
            logo_guidelines.pdf
            ----

            [source,bash]
            ----
            $ ls
            company_brand_book.pdf logo_guidelines.pdf
            $ ls -1
            company_brand_book.pdf
            logo_guidelines.pdf
            ----
          ccq: null
        - type: info
          name: Positional arguments vs. options
          sdbr: null
          ref: null
          txt: |
            Unlike positional arguments,
            the meaning of options aren't understood from their location,
            so they can appear in any order where they are allowed.
            The meaning of this will become clear later.
          ccq: null
        - type: info
          name: 'printing directory contents in reverse: `ls -r`'
          sdbr: null
          ref: null
          txt: |
            The `-r` argument of `ls` reverses the normal alphabetical order of the output.

            [source,bash]
            ----
            company_brand_book.pdf
            logo_guidelines.pdf
            ----

            [source,bash]
            ----
            $ ls
            company_brand_book.pdf logo_guidelines.pdf
            $ ls -r
            logo_guidelines.pdf company_brand_book.pdf
            ----
          ccq: null
      - name: Using multiple options
        txt: |
          null
          To print one column in reverse, we use `-1` and `-r`.
          [source,bash]
          ----
          company_brand_book.pdf
          logo_guidelines.pdf
          ----

          [source,bash]
          ----
          $ ls -r -1
          logo_guidelines.pdf
          company_brand_book.pdf
          ----
        inst:
        - type: info
          name: Options can appear in any order
          sdbr: null
          ref: null
          txt: |
            Options, unlike positional arguments,
            may occur in any order where they are allowed, so `-1 -r` works just like `-r -1`.

            [source,bash]
            ----
            company_brand_book.pdf
            logo_guidelines.pdf
            ----

            [source,bash]
            ----
            $ ls -r -1
            logo_guidelines.pdf
            company_brand_book.pdf
            $ ls -1 -r
            logo_guidelines.pdf
            company_brand_book.pdf
            ----
          ccq: null
        - type: info
          name: Combining options
          sdbr: null
          ref: null
          txt: |
            [source,bash]
            ----
            company_brand_book.pdf
            logo_guidelines.pdf
            ----
            As a shortcut, options can be bundled together, or _combined_.
            [source,bash]
            ----
            $ ls -1r
            logo_guidelines.pdf
            company_brand_book.pdf
            ----
          ccq: null
        - type: info
          name: Using options with positional arguments
          sdbr: null
          ref: null
          txt: |
            [source,bash]
            ----
            marketing
              campaigns
                Q1_product_launch.pdf
                summer_promo_plan.pdf
              branding
                logo_guidelines.pdf
                company_brand_book.pdf
            ----
            When CWD is `marketing/campaigns`,
            list the contents of /marketing/branding/ in a reversed single column.
            [source,bash]
            ----
            $ cd marketing/campaigns
            $ ls -1r marketing/branding
            logo_guidelines.pdf
            company_brand_book.pdf
            ----
            Because `marketing/branding` is a positional argument,

            `ls marketing/branding -1r`

            is invalid.


            Most commands have a specified area where options can occur.
            Within that area options can be in any order.
          ccq: null
        - type: info
          name: How Linux views arguments
          sdbr: null
          ref: null
          txt: |
            Consider the following command

            `ls -r -l /home/bob`

            Linux imposes no structure on arguments nor attempts to understand them.
            Linux converts everything after the command to a list and sends the list to the command
            and the command itself is responsible processing arguments.
            So, at program start, `ls` will receive something like this

            `["-r", "-l", "/home/bob/"]`

            Understanding and processing arguments is the responsibility of the command.
            Linux plays no part in it.
            Attempting to standardize,
            most Linux commands follow a certain pattern for their arguments,
            but some Linux commands are rogue and don't follow typical patterns.
          ccq: null
      - name: Deleting filesystem objects
        txt: |
          null
        inst:
        - type: info
          name: 'Deleting a single file: `rm`'
          sdbr: null
          ref: null
          txt: |
            [source, bash]
            ----
            sales_report_Jan.csv
            sales_forecast_Q1.pdf
            ----
            [source, bash]
            ----
            $ rm sales_forecast_Q1.pdf
            $ ls
            sales_report_Jan.csv
            ----
          ccq: null
        - type: info
          name: 'Deleting an empty directory: `rmdir`'
          sdbr: null
          ref: null
          txt: |
            [source, bash]
            ----
            client_contact/
              client_list.csv
            sales_reports/
            ----
            `rmdir` removes empty directories
            [source, bash]
            ----
            $ rmdir sales_reports
            $ ls
            client_contact
            ----
            If we try to delete a directory containing objects we get an error.
            [source, bash]
            ----
            $ rmdir client_contact
            ----
            rmdir: failed to remove 'client_contact': Directory not empty
          ccq: null

        - type: info
          name: 'Deleting a directory tree: `rm -rf`'
          sdbr: null
          ref: null
          txt: |
            `rm` provides a powerful option set to remove a directory and its contents but be careful using it.
            Its easy to make a mistake and delete important data.

            [source, bash]
            ----
            sales
              client_contact
                client_list.csv
            ----
            [source, bash]
            ----
            $ rm -rf sales
            $ ls sales
            ls: cannot access 'sales': No such file or directory
            ----

            `-r`: _recursive_: a fancy way of saying the command will search the entire directory tree
            `-f`: _force_: without this option, `rm` will prompt before deleting every file

            The most dangerous command possible is `rm -rf /`.
            This will delete everything in your filesystem and crash Linux.
            All data will be lost and Linux will require re-installation.
          ccq: null
    - name: More commands with options
      txt: |
        null
        So far, we have introduced these commands.

        * cat
        * cd
        * cp
        * echo
        * ls
        * mkdir
        * mv
        * pwd
        * rm
        * rmdir

        In addition, we introduced these options:

        * ls: -r, -1,
        * rm: -r, -f

        In this lesson we will explore useful options for many of these commands.
      modules:
      - name: Options for `cp`, `cat`, and `mkdir`
        txt: |
          null
        inst:
        - type: info
          name: 'Copying directory trees: `cp -a`'
          sdbr: null
          ref: null
          txt: |
            [source, bash]
            ----
            client_contact
              client_list.csv
            ----

            A quick form of backup is copying a directory and all its contents.
            Let's copy `client_contact`` to another directory in CWD.

            [source, bash]
            ----
            $ cp -a client_contact client_contact_backup
            $ ls
            client_contact client_contact_backup
            $ ls client_contact_backup
            client_list.csv
            ----
          ccq: null
        - type: info
          name: 'Do not overwrite existing file on copy: `cp -n`'
          sdbr: null
          ref: null
          txt: |
            [source, bash]
            ----
            password_policy_19.pdf
            password_policy_20.pdf
            ----
            [source, bash]
            ----
            $ cp -n password_policy_19.pdf password_policy_20.pdf
            ----
            In this situation, `password_policy_20.pdf` will remain unchanged.
            `cp` will not provide any notice that the file was not copied.
          ccq: null
        - type: info
          name: 'Numbering lines: `cat -n`'
          sdbr: null
          ref: null
          txt: |
            "Lorem ipsum" is a corrupted Latin text that is used when content is unimportant but text needs a placeholder.
            We will use Lorem ipsum for file content for this course.
            [source, bash]
            ----
            quick.txt
            ----
            `quick.txt` contains
            [source, bash]
            ----
            Lorem ipsum dolor sit amet,
            consectetur adipiscing elit,
            sed do eiusmod tempor incididunt
            ut labore et dolore magna aliqua.
            ----
            [source, bash]
            ----
            $ cat -n lorem.txt
            1	Lorem ipsum dolor sit amet,
            2	consectetur adipiscing elit,
            3	sed do eiusmod tempor incididunt
            4	ut labore et dolore magna aliqua.
            ----
          ccq: null
        - type: info
          name: 'Create complete paths: `mkdir -p`'
          sdbr: null
          ref: null
          txt: |
            When we want to create a directory where more than one level doesn't exist, `mkdir` will fail.
            [source, bash]
            ----
            $ mkdir /marketing/bob
            mkdir: cannot create directory '/marketing/bob': No such file or directory
            $ mkdir -p /marketing/bob
            $ ls
            marketing
            $ ls marketing
            bob
            ----
          ccq: null
      - name: More `ls` options
        txt: |
          null
        inst:
        - type: info
          name: 'List extended object information: `ls -l`'
          sdbr: null
          ref: null
          txt: |
            [source, bash]
            ----
            branding
              company_brand_book.pdf
              logo_guidelines.pdf
            ----
            [source, bash]
            ----
            $ ls -l
            -rw-r--r-- 1 bob bob  1049 Feb  8 01:30 company_brand_book.pdf
            -rw-r--r-- 1 bob bob   124 Feb  8 05:46 logo_guidelines.pdf
            ----
            Most of the output can't be understood until later in the course,
            but the file sizes (1049 and 124) and file date and times are provided.
          ccq: null
        - type: info
          name: 'List object information recursively: `ls -R`'
          sdbr: null
          ref: null
          txt: |
            [source, bash]
            ----
            security
              password_policy.pdf
              security_audit_report.pdf
            software
              accounting_software_guide.pdf
              crm_tool_manual.pdf
            ----

            [source, bash]
            ----
            $ ls -R
            security
              password_policy.pdf
              security_audit_report.pdf
            software
              accounting_software_guide.pdf
              crm_tool_manual.pdf
            ----
            `ls -r` displays the entire directory tree.
          ccq: null
        - type: info
          name: 'List objects sorted by time: `ls -t`'
          sdbr: null
          ref: null
          txt: |
            `ls -t` changes from the default alphabetical sort order to ordering from most recent to oldest.
            [source, bash]
            ----
            $ ls -l
            -rw-r--r-- 1 kev kev   7777 Feb  2 23:20 slides.py
            -rw-r--r-- 1 kev kev   2334 Jan 29 22:50 reference.txt
            $ ls -lt
            -rw-r--r-- 1 kev kev   2334 Jan 29 22:50 reference.txt
            -rw-r--r-- 1 kev kev   7777 Feb  2 23:20 slides.py
            ----
          ccq: null
        - type: info
          name: 'Listing file objects with markers: `ls -F`'
          sdbr: null
          ref: null
          txt: |
            [source, bash]
            ----
            password_policy.pdf
            security
            ----
            [source, bash]
            ----
            $ ls -F
            password_policy.pdf security/
            ----
            Notice that `security` has `/` after it to indicate a directory.
            `-F` has several other markers that will be explored later.
          ccq: null
