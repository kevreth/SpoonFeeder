name: Bash
txt: null
units:
- name: Basic Bash
  txt: null
  lessons:
  - name: Introduction
    txt: null
    modules:
    - name: What is Bash?
      txt: null
      inst:
      - name: What is Bash?
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          _Bash_ is a _command line interface_ (CLI) to Linux and many other operating systems.
          After starting Bash, something like this will appear with no indication of what to do next.

          `$`
      - name: Bash commands
        type: info
        sdbr: null
        ref: null
        txt: |
          The most common way to interact with Bash is by typing _commands_.

          `$`

          is called the _prompt_ and where commands can be typed in.
          The prompt is automatically displayed immediately after initiating a Bash session.
        ccq: null
      - name: 'Printing to the screen: `echo`'
        type: info
        sdbr: null
        ref: null
        txt: |
          Our first Bash command will print to the screen.
          Anything after the prompt (`$`) on the same line is content you would type.

          [source, bash]
          ----
          $ echo "Hello World!"
          Hello World!
          ----

          Always press the `ENTER` (or on some systems `RETURN`) key after finishing typing a command to execute (run) it.
          In this case, we would type

          `echo "Hello World!"<ENTER>`

          <ENTER> means pressing the ENTER key, not to type out < E N T E R > literally.

          After executing the command,

          `Hello World!`

          should display underneath the prompt and a new prompt provided.
    - name: GUIs and Bash
      txt: null
      inst:
      - name: GUIs and Bash
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          Unless a _graphical user interface_ (GUI) is started with lots of pretty windows that move around,
          Bash will probably be what is seen after logging into a Linux computer.
          So, after entering a correct username and password,
          if a GUI is started, then Bash can be started in a window of the GUI but
          the specific method varies among Linux systems.
      - name: Bash CLI vs a GUI
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          ++++
          <div style="display: flex; justify-content: left; align-items: flex-start;">
          <div style="flex: 1; padding: 0px;">
            <b style="margin:auto">Bash CLI vs. a GUI</b>
          ++++

          [source,bash]
          ----
          $ pwd
          /home/user
          $ ls
          Documents  Downloads  Pictures  Projects
          ----

          ++++
          </div>
          <div style="flex: 1; padding: 10px;">
          ++++

          image::gui.svg[GUI example,opts="inline"]

          ++++
          </div>
          </div>
          ++++
      - name: Why use Bash instead of a GUI?
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          One may wonder why a CLI like Bash is worth learning when an easily learned and used GUI is available.
          The answer is,

          * CLIs make certain types of tasks easier.
          * Some tasks cannot be done without Bash because a GUI equivalent is unavailable.
          * Typing is faster than using the mouse for most tasks.
  - name: The Linux filesystem
    txt: |
      `echo`, the only command studied so far,
      doesn't require using persistent data storage.

      The Bash commands we will be learning at first use persistent data storage,
      so this lesson explains how persistent storage works in Linux.
    modules:
    - name: Filesystem objects
      txt:  null
      inst:
      - name: Filesystems
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          A _filesystem_ is how computers store data on permanent storage devices such as disk drives.
      - name: Directories and files
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          Filesystems contain primarily two types of items, known as _objects_: _directories_ and _files_.
      - name: Files
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          _Files_ contain data.
          A file can contain any type of computer data.
          Examples include

          * text documents,
          * music tracks, or
          * software programs.

          Files cannot contain other files.
      - name: Directories
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          _Directories_ are an organization tool.
          Directories contain files and other directories but cannot directly contain data like files can.
      - name: The relationship of directories, files, and data.
        type: info
        sdbr: null
        ref: null
        ccq: null
        ccq: null
        txt: |
          Arrows represent containership.
          [graphviz, format="svg"]
          ....
          digraph g {
            files -> data
            directories -> files
            directories -> directories
          }
          ....
          Directories can contain directories and files, files contain data.
      - name: Filesystems analogy
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          Comparing a filesystem to a tree,
          directories are tree branches and files are leaves.
          Branches can grow from the trunk and other branches.
          Leaves (files) can grow anywhere, including the tree trunk.
    - name: More about filesystems
      txt:  null
      inst:
      - name: The root directory
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          At the top of the tree is the _root directory_ which corresponds to a tree trunk.
          There can be only one root directory and it is named "/",
          which is the character _frontslash_ ("\" is a "backslash").
      - name: An example filesystem
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          An example filesystem.
          Arrows represent containership.

          [graphviz, format="svg"]
          ....
          digraph g {
            "/" -> dir1
            "/" -> dir2
            "/" -> file1
            "/" -> file2
            dir1 -> file4
            dir1 -> file5
            dir1 -> dir4 -> file9
            dir1 -> dir5 -> file10
            dir2 -> dir6 -> file11
            dir2 -> dir7 -> file12
            dir2 -> file8
          }
          ....

          In this simple filesystem, the root directory contains two directories and two files.
          Each of those two directories also contain directories and files.
      - name: Filesystem limits
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          There is no practical limit to the number of directories and files a directory can contain,
          nor is there a practical limit to how deep directories can branch to other directories.
      - name: Filesystem object naming
        type: info
        sdbr: null
        ref: null
        txt: |
          Each filesystem object has a name associated with it.

          [graphviz, format="svg"]
          ....
          digraph g {
            "/" -> bob
            "/" -> sue
            "/" -> "report.q1.txt"
            "/" -> "report.q2.txt"
            bob -> "party.txt"
            bob -> "party.mp4"
            sue -> "ap.txt"
          }
          ....
          In this example, the root directory contains directories for "bob" and "sue" and two files.
          "bob" contains two files and "sue" contains one file.
        ccq: null
      - name: Filesystem paths
        type: info
        sdbr: null
        ref: null
        txt: |
          We can address any object on a filesystem using a _path_.

          [graphviz, format="svg"]
          ....
          digraph g {
            "/" [style=filled, fillcolor=lightblue]
            bob [style=filled, fillcolor=lightblue]
            "party.txt" [style=filled, fillcolor=lightblue]
            "/" -> bob
            "/" -> sue
            "/" -> "report.q1.txt"
            "/" -> "report.q2.txt"
            bob -> "party.txt"
            bob -> "party.mp4"
            sue -> "ap.txt"
          }
          ....

          The directories necessary to address any file or directory in a file path are separated by "/".

          The path to "holiday.party.txt" is "/bob/holiday.party.txt".

          Every object on the filesystem can be addressed this way.
        ccq: null
    - name: Representing directory contents
      txt: null
      inst:
      - name: Graphical representation
        type: info
        sdbr: null
        ref: null
        txt: |
          Up to now, directory contents have been presented graphically:
          [graphviz, format="svg"]
          ....
          digraph g {
            "/" -> bob
            "/" -> sue
            bob -> "party.txt"
            sue -> "ap.txt"
          }
          ....
      - name: Textual representation
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          From now on, directory contents will be presented textually,
          which is how you would see them when using Bash.
          [source]
          ----
          /home/employees
            bob
              party.txt
            sue
              ap.txt
          ----
      - name: Removing the file path
        type: info
        sdbr: null
        ref: null
        txt: |
          Most of the time when discussing directories
          we don't want to worry about the parent directories up to the root.
          We only want to be concerned with a single directory under discussion.
          So, we leave out the path to the directory and remove indentation of the contents.
          [source]
          ----
          bob
            party.txt
          sue
            ap.txt
          ----
          This directory is the contents of the "/home/employees" directory seen in the last slide
          with the path removed and the contents not indented.
          This is the standard way directory contents will be displayed.
          We often do not know or care where on the filesystem "employees" is located.
          In most cases it's not important.
      - name: Empty directories
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          [source]
          ----
          bob
            party.txt
          amy/
          ----
          `amy` is an empty directory containing no objects.
          To distinguish empty directories from files, empty directories have a frontslash after them.
    - name: More about directories and files
      txt: null
      inst:
      - name: 'File paths: file extensions'
        type: info
        sdbr: null
        ref: null
        txt: |
          By convention, a file ends with a short identifier,
          called a _file extension_ indicating the type of file,
          but it's not a requirement.

          `annual.report.q1.txt` is a text file.

          `corporate.retreat.mp4` is an mp4 video file.

          Hundreds of standard file extensions exist.
          You will learn more file extensions as you learn Bash.
        ccq: null
      - name: Directory contents must have unique names
        type: info
        sdbr: null
        ref: null
        txt: |
          Within a single directory, no two objects can have the same name.
          So within `/bob/` there cannot be any file or directory with the same name as another file or directory in `/bob/`.
          Two objects in the filesystem may be named identically but they must be in different directories.

          This cannot occur.

          [source, bash]
          ----
          /bob/test.txt
          /bob/test.txt
          ----

          However this is fine.

          [source, bash]
          ----
          /bob/test.txt
          /sue/test.txt
          ----

          Beyond their role in organization, directories prevent name conflicts.
        ccq: null
  - name: Beginning Bash
    txt: null
    modules:
    - name: The Bash interface
      txt: null
      inst:
      - name: Current working directories
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          Every Bash session has an associated _current working directory_ (CWD).
          Think of the CWD as your current location on the filesystem.

          [source, bash]
          ----
          annual.report.q1.txt
          annual.report.q2.txt
          bob
            holiday.party.txt
            corporate.retreat.mp4
          sue
            accounts.payable.txt
          ----

          The contents of the CWD can be addressed without using complete file paths.
          If our CWD is "bob" then we can address "holiday.party.txt" without preceding with "/bob/".
      - name: Home directories
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          When starting Bash, your CWD is normally the _home directory_ of the user you logged in as.
          Unless configured otherwise, the home directory follows the pattern

          `/home/<username>`

          So if you are logged in under "bob", your home directory, and where Bash starts, will be

          `/home/bob/`

          The home directory is your personal space on the filesystem.
          Within it, you are free to create directories and files.
    - name: The current working directory
      txt: null
      inst:
      - name: Displaying the CWD
        type: info
        sdbr: null
        ref: null
        txt: |
          From now on, many slides will display a listing of CWD at the beginning.
          For example,

          [source, bash]
          ----
          annual.report.q1.txt
          annual.report.q2.txt
          bob
            holiday.party.txt
            corporate.retreat.mp4
          sue
            accounts.payable.txt
          ----

          will be provided without identification.

          Just know that's the tree of the CWD you're working with.
          In most cases, the CWD will only be identified if significant..
        ccq: null
      - name: 'Printing the path of the CWD: `pwd`'
        type: info
        sdbr: null
        ref: null
        txt: |
          If the CWD is `/home/bob/`, then

          [source, bash]
          ----
          $ pwd
          /home/bob
          ----
        ccq: null
      - name: 'changing the CWD: `cd`'
        type: info
        sdbr: null
        ref: null
        txt: |
          [source, bash]
          ----
          bob/
          ----

          [source, bash]
          ----
          $ cd bob
          $ pwd
          bob
          ----
        ccq: null
    - name: Creating and viewing file objects
      txt: null
      inst:
      - name: 'Listing directory contents: `ls`'
        type: info
        sdbr: null
        ref: null
        txt: |
          [source, bash]
          ----
          corporate.retreat.mp4
          holiday.party.txt
          ----

          [source, bash]
          ----
          $ ls
          corporate.retreat.mp4 holiday.party.txt
          ----

          `ls` by itself does not provide any indication of what the type of the objects are.
          We will see later how to view more object information.
        ccq: null
      - name: 'Creating a new directory: `mkdir`'
        type: info
        sdbr: null
        ref: null
        txt: |
          [source, bash]
          ----
          bob/
          ----

          [source, bash]
          ----
          $ mkdir sue
          $ ls
          bob sue
          ----
        ccq: null
      - name: 'Creating a file: `>`'
        type: info
        sdbr: null
        ref: null
        txt: |
          Bash features _output redirection_ to send the output of a command to a file.
          The pattern of redirection is *always*

          <command> <redirection operator> <file>

          Earlier we used the `echo` command to print a message to the screen.
          This time we will use output redirection to instead create a file to contain the output of `echo`.

          Here, the _output redirector_ `>` is used to create a new file and add content to it.

          [source, bash]
          ----
          $ echo "this is a line" > test.txt
          $ ls
          test.txt
          ----
        ccq: null
      - name: 'Viewing file contents: `cat`'
        type: info
        sdbr: null
        ref: null
        txt: |
          [source, bash]
          ----
          $ echo "this is a line" > test.txt
          $ cat test.txt
          this is a line
          ----
        ccq: null
      - name: '`>` overwrites files'
        type: info
        sdbr: null
        ref: null
        txt: |
          The redirector used earlier `>`, overwrites any existing file content.

          [source, bash]
          ----
          $ echo "line 1" > test.txt
          $ cat test.txt
          line 1
          $ echo "line 2" > test.txt
          $ cat test.txt
          line 2
          ----
          "line 1" was overwritten.
      - name: 'Adding more lines: `>>`'
        type: info
        sdbr: null
        ref: null
        txt: |
          Instead of overwriting, add a second line using the _append redirector_ (`>>`).
          [source, bash]
          ----
          $ echo "second line" >> test.txt
          $ cat test.txt
          first line
          second line
          ----
          Like the output redirector,
          the file will be created if it doesn't exist,
          so to prevent data loss,
          prefer append redirection to output redirection.
        ccq: null
    - name: Copying, renaming, and moving objects
      txt: null
      inst:
      - name: 'Copying files: `cp`'
        type: info
        sdbr: null
        ref: null
        txt: |
          `cp` copies filesystem objects.

          [source, bash]
          ----
          $ echo "test" > test.txt
          $ cp test.txt sample.txt
          $ ls
          test.txt sample.txt
          ----
          `cp` cannot copy directories this way.
          We will look at directory copying later.
        ccq: null
      - name: 'Renaming files: `mv`'
        type: info
        sdbr: null
        ref: null
        txt: |
          `mv` renames and moves filesystem objects.

          [source, bash]
          ----
          $ echo "first line" > test.txt
          $ mv test.txt test0.txt
          $ ls
          test0.txt
          ----

          `mv` is an abbreviation of "move".
          Think of "move" as "moving to a new path" where the path includes the filename.
        ccq: null
      - name: 'Moving files: `mv`'
        type: info
        sdbr: null
        ref: null
        txt: |
          If we want to move the file to the home directory we can use `mv` also

          [source, bash]
          ----
          $ mkdir /steve/
          $ echo "first line" > test.txt
          $ mv test.txt /steve/
          $ ls /steve/
          test.txt
          ----

          With `mv`, we're changing the path to a file or directory; "moving to a new path".
      - name: 'Moving and renaming files simultaneously: `mv`'
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          Since `mv` moves to a different path,
          it can rename the file and move it to a different directory simultaneously.

          [source, bash]
          ----
          $ mkdir /steve/
          $ echo "first line" > test.txt
          $ mv test.txt /steve/line.txt
          $ cd /steve/
          $ ls
          line.txt
          ----
    - name: Deleting filesystem objects
      txt: null
      inst:
      - name: 'Deleting a single file: `rm`'
        type: info
        sdbr: null
        ref: null
        txt: |
          [source, bash]
          ----
          sales_report_Jan.csv
          sales_forecast_Q1.pdf
          ----
          [source, bash]
          ----
          $ rm sales_forecast_Q1.pdf
          $ ls
          sales_report_Jan.csv
          ----
        ccq: null
      - name: 'Deleting an empty directory: `rmdir`'
        type: info
        sdbr: null
        ref: null
        txt: |
          [source, bash]
          ----
          client_contact/
            client_list.csv
          sales_reports/
          ----
          `rmdir` removes empty directories
          [source, bash]
          ----
          $ rmdir sales_reports
          $ ls
          client_contact
          ----
          If we try to delete a directory containing objects we get an error.
          [source, bash]
          ----
          $ rmdir client_contact
          ----
          rmdir: failed to remove 'client_contact': Directory not empty
        ccq: null
  - name: Command arguments
    txt: |
      null
    modules:
    - name: sad
      txt: null
      inst:
      - name: The many meanings of "command"
        type: info
        sdbr: null
        ref: null
        txt: |
          The use of "command" has been used in different ways.

          * A command as in `echo` (a basic command)
          * A command as in `echo test.txt` (a command with arguments)
          * A command as in `echo test.txr > test.txt` (everything typed before pressing ENTER)

          All three of these are correct.
          While it may seem a problem,
          in practice which of the three meanings of "command" is intended is understood from context.
        ccq: null
      - name: Arguments we've already seen
        type: info
        sdbr: null
        ref: null
        txt: |
          We've seen several cases where a command was used
          with some additional information (which together is also a command):

          * `cd bash-tutorial`
          * `cp test.txt sample.txt`
          * `echo "this is a line"`
          * `mkdir /home/bob/`
          * `mv test.txt test0.txt`

          Instances of that additional information are called _arguments_.
          The arguments we've seen so far are _positional arguments_ and are the simplest type of arguments.
          The meanings of positional arguments are understood based on their location in the arguments.
          For example, with `mv`,

          `mv test.txt test0.txt`

          The first positional argument is always the existing file object and
          the second positional argument is always the new location.
          They cannot be reversed.

          Redirectors (`>`, `>>`) are not arguments.
        ccq: null
    - name: Positional arguments
      txt: Most of the Linux commands we've see so far can take positional arguments in ways we haven't used yet.
      inst:
      - name: ls
        type: info
        sdbr: null
        ref: null
        txt: |

        ccq: null
      - name: cp
        type: info
        sdbr: null
        ref: null
        txt: |

        ccq: null
      - name: mkdir
        type: info
        sdbr: null
        ref: null
        txt: |

        ccq: null
      - name: mv
        type: info
        sdbr: null
        ref: null
        txt: |

        ccq: null
      - name: rm
        type: info
        sdbr: null
        ref: null
        txt: |

        ccq: null
      - name: rmdir
        type: info
        sdbr: null
        ref: null
        txt: |
          rmdir
        ccq: null
      - name: cat
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          cat
      - name: echo
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          echo
    - name: Options
      txt: null
      inst:
      - name: 'Option example: `ls -1`'
        type: info
        sdbr: null
        ref: null
        txt: |
          An _option_ is an argument of one letter preceded by a dash "-".
          An example of using an option is `-1` used with `ls`.
          `-1` (one-column) instructs `ls` to list directory contents vertically instead of horizontally.

          [source,bash]
          ----
          company_brand_book.pdf
          logo_guidelines.pdf
          ----

          [source,bash]
          ----
          $ ls
          company_brand_book.pdf logo_guidelines.pdf
          $ ls -1
          company_brand_book.pdf
          logo_guidelines.pdf
          ----
        ccq: null
      - name: 'Printing directory contents in reverse: `ls -r`'
        type: info
        sdbr: null
        ref: null
        txt: |
          The `-r` argument of `ls` reverses the normal alphabetical order of the output.

          [source,bash]
          ----
          company_brand_book.pdf
          logo_guidelines.pdf
          ----

          [source,bash]
          ----
          $ ls
          company_brand_book.pdf logo_guidelines.pdf
          $ ls -r
          logo_guidelines.pdf company_brand_book.pdf
          ----
        ccq: null
      - name: Using multiple options
        type: info
        sdbr: null
        ref: null
        txt: |
          [source,bash]
          ----
          company_brand_book.pdf
          logo_guidelines.pdf
          ----
          To print `ls` output in one column in reverse order:
          [source,bash]
          ----
          $ ls -1 -r
          logo_guidelines.pdf
          company_brand_book.pdf
          ----
        ccq: null
    - name: Using multiple options
      txt: |
        To print `ls` output in a reversed single column, we use `-1` and `-r`.
        [source,bash]
        ----
        company_brand_book.pdf
        logo_guidelines.pdf
        ----

        [source,bash]
        ----
        $ ls -r -1
        logo_guidelines.pdf
        company_brand_book.pdf
        ----
      inst:
      - name: Options can appear in any order
        type: info
        sdbr: null
        ref: null
        txt: |
          Options, unlike positional arguments,
          may occur in any order where they are allowed, so `-1 -r` works just like `-r -1`.

          [source,bash]
          ----
          company_brand_book.pdf
          logo_guidelines.pdf
          ----

          [source,bash]
          ----
          $ ls -r -1
          logo_guidelines.pdf
          company_brand_book.pdf
          $ ls -1 -r
          logo_guidelines.pdf
          company_brand_book.pdf
          ----
        ccq: null
      - name: Combining options
        type: info
        sdbr: null
        ref: null
        txt: |
          [source,bash]
          ----
          company_brand_book.pdf
          logo_guidelines.pdf
          ----
          As a shortcut, options can be bundled together, or _combined_.
          [source,bash]
          ----
          $ ls -1r
          logo_guidelines.pdf
          company_brand_book.pdf
          ----
        ccq: null
      - name: Using options with positional arguments
        type: info
        sdbr: null
        ref: null
        txt: |
          [source,bash]
          ----
          marketing
            campaigns
              Q1_product_launch.pdf
              summer_promo_plan.pdf
            branding
              logo_guidelines.pdf
              company_brand_book.pdf
          ----
          When CWD is `marketing/campaigns`,
          list the contents of `/marketing/branding/` in a reversed single column.
          [source,bash]
          ----
          $ cd marketing/campaigns
          $ ls -1r marketing/branding
          logo_guidelines.pdf
          company_brand_book.pdf
          ----
          Because `marketing/branding` is a positional argument,

          `ls marketing/branding -1r`

          is invalid.


          Most commands have a specified area where options can occur.
          Within that area options can be in any order.
        ccq: null
      - name: How Linux views arguments
        type: info
        sdbr: null
        ref: null
        txt: |
          Consider the following command

          `ls -r -l /home/bob`

          Linux imposes no structure on arguments nor attempts to understand them.
          Linux converts everything after the command to a list and sends the list to the command
          and the command itself is responsible processing arguments.
          So, at program start, `ls` will receive something like this

          `["-r", "-l", "/home/bob/"]`

          Understanding and processing arguments is the responsibility of the command.
          Linux plays no part in it.
          Attempting to standardize,
          most Linux commands follow a certain pattern for their arguments,
          but some Linux commands are rogue and don't follow typical patterns.
        ccq: null
  - name: More commands with options
    txt: |
      null
      So far, we have introduced these commands.

      * cat
      * cd
      * cp
      * echo
      * ls
      * mkdir
      * mv
      * pwd
      * rm
      * rmdir

      In addition, we introduced these options:

      * ls: -r, -1,
      * rm: -r, -f

      In this lesson we will explore useful options for many of these commands.
    modules:
    - name: Options for `cp`, `cat`, `mkdir`, and `rm`
      txt: null
      inst:
      - name: 'Copying directory trees: `cp -a`'
        type: info
        sdbr: null
        ref: null
        txt: |
          [source, bash]
          ----
          client_contact
            client_list.csv
          ----

          A quick form of backup is copying a directory and all its contents.
          Let's copy `client_contact`` to another directory in CWD.

          [source, bash]
          ----
          $ cp -a client_contact client_contact_backup
          $ ls
          client_contact client_contact_backup
          $ ls client_contact_backup
          client_list.csv
          ----
        ccq: null
      - name: 'Do not overwrite existing file on copy: `cp -n`'
        type: info
        sdbr: null
        ref: null
        txt: |
          [source, bash]
          ----
          password_policy_19.pdf
          password_policy_20.pdf
          ----
          [source, bash]
          ----
          $ cp -n password_policy_19.pdf password_policy_20.pdf
          ----
          In this situation, `password_policy_20.pdf` will remain unchanged.
          `cp` will not provide any notice that the file was not copied.
        ccq: null
      - name: 'Numbering lines: `cat -n`'
        type: info
        sdbr: null
        ref: null
        txt: |
          "Lorem ipsum" is a corrupted Latin text
          that is used when content is unimportant but text needs a placeholder.
          We will use Lorem ipsum for file content for this course.
          [source, bash]
          ----
          lorem.txt
          ----
          [source, bash]
          ----
          cat lorem.txt
          Lorem ipsum dolor sit amet,
          consectetur adipiscing elit,
          sed do eiusmod tempor incididunt
          ut labore et dolore magna aliqua.
          $ cat -n lorem.txt
          1	Lorem ipsum dolor sit amet,
          2	consectetur adipiscing elit,
          3	sed do eiusmod tempor incididunt
          4	ut labore et dolore magna aliqua.
          ----
        ccq: null
      - name: 'Create complete paths: `mkdir -p`'
        type: info
        sdbr: null
        ref: null
        txt: |
          When we want to create a directory where more than one level doesn't exist, `mkdir` will fail.
          [source, bash]
          ----
          $ mkdir /marketing/bob
          mkdir: cannot create directory '/marketing/bob': No such file or directory
          $ mkdir -p /marketing/bob
          $ ls
          marketing
          $ ls marketing
          bob
          ----
        ccq: null
      - name: 'Deleting a directory tree: `rm -rf`'
        type: info
        sdbr: null
        ref: null
        txt: |
          `rm` provides a powerful option set to remove a directory and its contents but be careful using it.
          Its easy to make a mistake and delete important data.

          [source, bash]
          ----
          sales
            client_contact
              client_list.csv
          ----
          [source, bash]
          ----
          $ rm -rf sales
          $ ls sales
          ls: cannot access 'sales': No such file or directory
          ----

          `-r`: _recursive_: a fancy way of saying the command will search the entire directory tree
          `-f`: _force_: without this option, `rm` will prompt before deleting every file

          The most dangerous command possible is `rm -rf /`.
          This will delete everything in your filesystem and crash Linux.
          All data will be lost and Linux will require re-installation.
        ccq: null
    - name: More `ls` options
      txt: null
      inst:
      - name: 'List extended object information: `ls -l`'
        type: info
        sdbr: null
        ref: null
        txt: |
          [source, bash]
          ----
          branding
            company_brand_book.pdf
            logo_guidelines.pdf
          ----
          [source, bash]
          ----
          $ ls -l
          -rw-r--r-- 1 bob bob  1049 Feb  8 01:30 company_brand_book.pdf
          -rw-r--r-- 1 bob bob   124 Feb  8 05:46 logo_guidelines.pdf
          ----
          Most of the output can't be understood until later in the course,
          but the file sizes (1049 and 124) and file date and times are provided.
        ccq: null
      - name: 'List object information recursively: `ls -R`'
        type: info
        sdbr: null
        ref: null
        txt: |
          [source, bash]
          ----
          security
            password_policy.pdf
            security_audit_report.pdf
          software
            accounting_software_guide.pdf
            crm_tool_manual.pdf
          ----

          [source, bash]
          ----
          $ ls -R
          security
            password_policy.pdf
            security_audit_report.pdf
          software
            accounting_software_guide.pdf
            crm_tool_manual.pdf
          ----
          `ls -r` displays the entire directory tree.
        ccq: null
      - name: 'List objects sorted by time: `ls -t`'
        type: info
        sdbr: null
        ref: null
        txt: |
          `ls -t` changes from the default alphabetical sort order to ordering from most recent to oldest.
          [source, bash]
          ----
          $ ls -l
          -rw-r--r-- 1 kev kev   7777 Feb  2 23:20 slides.py
          -rw-r--r-- 1 kev kev   2334 Jan 29 22:50 reference.txt
          $ ls -lt
          -rw-r--r-- 1 kev kev   2334 Jan 29 22:50 reference.txt
          -rw-r--r-- 1 kev kev   7777 Feb  2 23:20 slides.py
          ----
        ccq: null
      - name: 'Listing file objects with markers: `ls -F`'
        type: info
        sdbr: null
        ref: null
        txt: |
          [source, bash]
          ----
          password_policy.pdf
          security
          ----
          [source, bash]
          ----
          $ ls -F
          password_policy.pdf security/
          ----
          Notice that `security` has `/` after it to indicate a directory.
          `-F` has several other markers that will be explored later.
        ccq: null
