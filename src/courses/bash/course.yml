name: Bash
txt: null
units:
- name: Basic Bash
  txt: null
  lessons:
  - name: Introduction
    txt: null
    modules:
    - name: What is Bash?
      txt: null
      inst:
      - name: What is Bash?
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: Is bash a _command line interface_ to Windows?
            ans: 'no'
        txt: |
          _Bash_ is a _command line interface_ (CLI) to Linux.
      - name: Bash commands
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: Commands are the most common way to interact with Bash.
            ans: 'yes'
          - type: bool
            txt: The prompts is where commands are typed in.
            ans: 'yes'
        ref: null
        txt: |
          The most common way to interact with Bash is by typing _commands_.

          `$`

          is called the _prompt_ and where commands can be typed in.
          The prompt is automatically displayed immediately after initiating a Bash session.
      - name: 'Printing to the screen: `echo`'
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: '`echo` prints to the screen.'
            ans: 'yes'
        txt: |
          Our first Bash command will print to the screen.
          Anything after the prompt (`$`) on the same line is content you would type.

          [source, bash]
          ----
          $ echo "Hello World!"
          Hello World!
          ----

          Always press the `ENTER` (or on some systems `RETURN`) key
          after finishing typing a command to execute (run) it.
          In this case, we would type

          `echo "Hello World!"<ENTER>`

          <ENTER> means pressing the ENTER key, not to type out < E N T E R > literally.

          After executing the command,

          `Hello World!`

          should display underneath the prompt and a new prompt provided.
    - name: GUIs and Bash
      txt: null
      inst:
      - name: GUIs and Bash
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        txt: |
          Unless a _graphical user interface_ (GUI) is started with lots of pretty windows that move around,
          Bash will probably be what is seen after logging into a Linux computer.
          So, after entering a correct username and password,
          if a GUI is started, then Bash can be started in a window of the GUI but
          the specific method varies among Linux systems.
      - name: Bash CLI vs a GUI
        type: info
        sdbr: null
        ref: null
        ccq: null
        txt: |
          ++++
          <div style="display: flex; justify-content: left; align-items: flex-start;">
          <div style="flex: 1; padding: 0px;">
            <b style="margin:auto">Bash CLI vs. a GUI</b>
          ++++

          [source,bash]
          ----
          $ pwd
          /home/user
          $ ls
          Documents  Downloads  Pictures  Projects
          ----

          ++++
          </div>
          <div style="flex: 1; padding: 10px;">
          ++++

          image::gui.svg[GUI example,opts="inline"]

          ++++
          </div>
          </div>
          ++++
      - name: Why use Bash instead of a GUI?
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: |
              A reason Bash is used when a GUI is available is because
              a mouse is faster than a keyboard.
            ans: 'no'
        txt: |
          One may wonder why a CLI like Bash is worth learning when
          an easily learned and used GUI is available.
          The answer is,

          * CLIs make certain types of tasks easier.
          * Some tasks cannot be done without Bash because a GUI equivalent is unavailable.
          * Typing is faster than using the mouse for most tasks.
  - name: The Linux filesystem
    txt: |
      `echo`, the only command studied so far,
      doesn't require using persistent data storage.

      The Bash commands we will be learning at first use persistent data storage,
      so this lesson explains how persistent storage works in Linux.
    modules:
    - name: Filesystem objects
      txt:  null
      inst:
      - name: Filesystems
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        txt: |
          A _filesystem_ is how computers store data on permanent storage devices such as disk drives.
      - name: Directories and files
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        txt: |
          Filesystems contain primarily two types of items, known as _objects_: _directories_ and _files_.
      - name: Files
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        txt: |
          _Files_ contain data.
          A file can contain any type of computer data.
          Examples include

          * text documents,
          * music tracks, or
          * software programs.

          Files cannot contain other files.
      - name: Directories
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        txt: |
          _Directories_ are an organization tool.
          Directories contain files and other directories but cannot directly contain data like files can.
      - name: The relationship of directories, files, and data.
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        txt: |
          Arrows represent containership.
          [graphviz, format="svg"]
          ....
          digraph g {
            files -> data
            directories -> files
            directories -> directories
          }
          ....
          Directories can contain directories and files, files contain data.
      - name: Filesystems analogy
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        txt: |
          Comparing a filesystem to a tree,
          directories are tree branches and files are leaves.
          Branches can grow from the trunk and other branches.
          Leaves (files) can grow anywhere, including the tree trunk.
    - name: More about filesystems
      txt:  null
      inst:
      - name: The root directory
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        txt: |
          At the top of the tree is the _root directory_ which corresponds to a tree trunk.
          There can be only one root directory and it is named "/",
          which is the character _frontslash_ ("\" is a "backslash").
      - name: An example filesystem
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        txt: |
          An example filesystem.
          Arrows represent containership.

          [graphviz, format="svg"]
          ....
          digraph g {
            "/" -> dir1
            "/" -> dir2
            "/" -> file1
            "/" -> file2
            dir1 -> file4
            dir1 -> file5
            dir1 -> dir4 -> file9
            dir1 -> dir5 -> file10
            dir2 -> dir6 -> file11
            dir2 -> dir7 -> file12
            dir2 -> file8
          }
          ....

          In this simple filesystem, the root directory contains two directories and two files.
          Each of those two directories also contain directories and files.
      - name: Filesystem limits
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        txt: |
          There is no practical limit to the number of directories and files a directory can contain,
          nor is there a practical limit to how deep directories can branch to other directories.
      - name: Filesystem object naming
        type: info
        sdbr: null
        ref: null
        txt: |
          Each filesystem object has a name associated with it.

          [graphviz, format="svg"]
          ....
          digraph g {
            "/" -> bob
            "/" -> sue
            "/" -> "report.q1.txt"
            "/" -> "report.q2.txt"
            bob -> "party.txt"
            bob -> "party.mp4"
            sue -> "ap.txt"
          }
          ....
          In this example, the root directory contains directories for "bob" and "sue" and two files.
          "bob" contains two files and "sue" contains one file.
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: Filesystem paths
        type: info
        sdbr: null
        ref: null
        txt: |
          We can address any object on a filesystem using a _path_.
          [graphviz, format="svg"]
          ....
          digraph g {
            "/" [style=filled, fillcolor=lightblue]
            bob [style=filled, fillcolor=lightblue]
            "party.txt" [style=filled, fillcolor=lightblue]
            "/" -> bob
            "/" -> sue
            "/" -> "report.q1.txt"
            "/" -> "report.q2.txt"
            bob -> "party.txt"
            bob -> "party.mp4"
            sue -> "ap.txt"
          }
          ....
          The directories necessary to address any file or directory in a file path are separated by "/".

          The path to "holiday.party.txt" is "/bob/holiday.party.txt".

          Every object on the filesystem can be addressed this way.
        ccq:
          - type: bool
            txt: question
            ans: 'no'
    - name: Representing directory contents
      txt: null
      inst:
      - name: Graphical representation
        type: info
        sdbr: null
        ref: null
        txt: |
          Up to now, directory contents have been presented graphically:
          [graphviz, format="svg"]
          ....
          digraph g {
            "/" -> bob
            "/" -> sue
            bob -> "party.txt"
            sue -> "ap.txt"
          }
          ....
      - name: Textual representation
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        txt: |
          From now on, directory contents will be presented textually,
          which is how you would see them when using Bash.
          [source]
          ----
          /home/employees
            bob
              party.txt
            sue
              ap.txt
          ----
      - name: Removing the file path
        type: info
        sdbr: null
        ref: null
        txt: |
          Most of the time when discussing directories
          we don't want to worry about the parent directories up to the root.
          We only want to be concerned with a single directory under discussion.
          So, we leave out the path to the directory and remove indentation of the contents.
          [source]
          ----
          bob
            party.txt
          sue
            ap.txt
          ----
          This directory is the contents of the "/home/employees" directory seen in the last slide
          with the path removed and the contents not indented.
          This is the standard way directory contents will be displayed.
          We often do not know or care where on the filesystem "employees" is located.
          In most cases it's not important.
      - name: Empty directories
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        txt: |
          [source]
          ----
          bob
            party.txt
          amy/
          ----
          `amy` is an empty directory containing no objects.
          To distinguish empty directories from files, empty directories have a frontslash after them.
    - name: More about directories and files
      txt: null
      inst:
      - name: 'File paths: file extensions'
        type: info
        sdbr: null
        ref: null
        txt: |
          By convention, a file ends with a short identifier,
          called a _file extension_ indicating the type of file,
          but it's not a requirement.

          `annual.report.q1.txt` is a text file.

          `corporate.retreat.mp4` is an mp4 video file.

          Hundreds of standard file extensions exist.
          You will learn more file extensions as you learn Bash.
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: Directory contents must have unique names
        type: info
        sdbr: null
        ref: null
        txt: |
          Within a single directory, no two objects can have the same name.
          So within `/bob/` there cannot be any file or directory with the same name as another file or directory in `/bob/`.
          Two objects in the filesystem may be named identically but they must be in different directories.

          This cannot occur.

          [source, bash]
          ----
          /bob/test.txt
          /bob/test.txt
          ----

          However this is fine.

          [source, bash]
          ----
          /bob/test.txt
          /sue/test.txt
          ----

          Beyond their role in organization, directories prevent name conflicts.
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: Parent directories and subdirectories
        type: info
        sdbr: null
        ref: |
          [source, bash]
          ----
          /accounting/financial.statements
            annual/
            quarterly/
          ----
        txt: |
          From the perspective of the CWD (/accounting/financial.statements),
          /accounting is the _parent directory_.
          A directory can only have one parent directory.

          "annual" and "quarterly" are _subdirectories_ of financial.statements.
          They could also be called "child directories" but "subdirectories" is the common term.
          A directory can have any number of subdirectories.
  - name: Beginning Bash
    txt: null
    modules:
    - name: The Bash interface
      txt: null
      inst:
      - name: Current working directories
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        txt: |
          Every Bash session has an associated _current working directory_ (CWD).
          Think of the CWD as your current location on the filesystem.

          [source, bash]
          ----
          annual.report.q1.txt
          annual.report.q2.txt
          bob
            holiday.party.txt
            corporate.retreat.mp4
          sue
            accounts.payable.txt
          ----

          The contents of the CWD can be addressed without using complete file paths.
          If our CWD is "bob" then we can address "holiday.party.txt" without preceding with "/bob/".
      - name: Home directories
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        txt: |
          When starting Bash, your CWD is normally the _home directory_ of the user you logged in as.
          Unless configured otherwise, the home directory follows the pattern

          `/home/<username>`

          So if you are logged in under "bob", your home directory, and where Bash starts, will be

          `/home/bob/`

          The home directory is your personal space on the filesystem.
          Within it, you are free to create directories and files.
    - name: The current working directory
      txt: null
      inst:
      - name: Displaying the CWD
        type: info
        sdbr: null
        ref: null
        txt: |
          From now on, many slides will display a listing of CWD at the beginning.
          For example,

          [source, bash]
          ----
          annual.report.q1.txt
          annual.report.q2.txt
          bob
            holiday.party.txt
            corporate.retreat.mp4
          sue
            accounts.payable.txt
          ----

          will be provided without identification.

          Just know that's the tree of the CWD you're working with.
          In most cases, the CWD will only be identified if significant..
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: 'Printing the path of the CWD: `pwd`'
        type: info
        sdbr: null
        ref: null
        txt: |
          If the CWD is `/home/bob/`, then

          [source, bash]
          ----
          $ pwd
          /home/bob
          ----
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: 'changing the CWD: `cd`'
        type: info
        sdbr: null
        ref: |
          .CWD
          [source, bash]
          ----
          bob/
          ----
        txt: |
          [source, bash]
          ----
          $ cd bob
          $ pwd
          bob
          ----
        ccq:
          - type: bool
            txt: question
            ans: 'no'
    - name: Creating and viewing file objects
      txt: null
      inst:
      - name: 'Listing directory contents: `ls`'
        type: info
        sdbr: null
        ref: |
          .CWD
          [source, bash]
          ----
          corporate.retreat.mp4
          holiday.party.txt
          ----
        txt: |
          [source, bash]
          ----
          $ ls
          corporate.retreat.mp4 holiday.party.txt
          ----

          `ls` by itself does not provide any indication of what the type of the objects are.
          We will see later how to view more object information.
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: 'Creating a new directory: `mkdir`'
        type: info
        sdbr: null
        ref: |
          .CWD
          [source, bash]
          ----
          bob/
          ----
        txt: |
          [source, bash]
          ----
          $ mkdir sue
          $ ls
          bob sue
          ----
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: 'Creating a file: `>`'
        type: info
        sdbr: null
        ref: null
        txt: |
          Bash features _output redirection_ to send the output of a command to a file.
          The pattern of redirection is *always*

          <command> <redirection operator> <file>

          Earlier we used the `echo` command to print a message to the screen.
          This time we will use output redirection to instead create a file to contain the output of `echo`.

          Here, the _output redirector_ `>` is used to create a new file and add content to it.

          [source, bash]
          ----
          $ echo "this is a line" > test.txt
          $ ls
          test.txt
          ----
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: 'Viewing file contents: `cat`'
        type: info
        sdbr: null
        ref: null
        txt: |
          [source, bash]
          ----
          $ echo "this is a line" > test.txt
          $ cat test.txt
          this is a line
          ----
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: '`>` overwrites files'
        type: info
        sdbr: null
        ref: null
        txt: |
          The redirector used earlier `>`, overwrites any existing file content.
          [source, bash]
          ----
          $ echo "line 1" > test.txt
          $ cat test.txt
          line 1
          $ echo "line 2" > test.txt
          $ cat test.txt
          line 2
          ----
          "line 1" was overwritten.
      - name: 'Adding more lines: `>>`'
        type: info
        sdbr: null
        ref: null
        txt: |
          Instead of overwriting, add a second line using the _append redirector_ (`>>`).
          [source, bash]
          ----
          $ echo "second line" >> test.txt
          $ cat test.txt
          first line
          second line
          ----
          Like the output redirector,
          the file will be created if it doesn't exist,
          so to prevent data loss,
          prefer append redirection to output redirection.
        ccq:
          - type: bool
            txt: question
            ans: 'no'
    - name: Copying, renaming, and moving objects
      txt: null
      inst:
      - name: 'Copying files: `cp`'
        type: info
        sdbr: null
        ref: null
        txt: |
          `cp` copies filesystem objects.
          [source, bash]
          ----
          $ echo "test" > test.txt
          $ cp test.txt sample.txt
          $ ls
          test.txt sample.txt
          ----
          `cp` cannot copy directories this way.
          We will look at directory copying later.
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: 'Renaming files: `mv`'
        type: info
        sdbr: null
        ref: null
        txt: |
          `mv` renames and moves filesystem objects.
          [source, bash]
          ----
          $ echo "first line" > test.txt
          $ mv test.txt test0.txt
          $ ls
          test0.txt
          ----
          `mv` is an abbreviation of "move".
          Think of "move" as "moving to a new path" where the path includes the filename.
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: 'Moving files: `mv`'
        type: info
        sdbr: null
        ref: null
        txt: |
          If we want to move the file to the home directory we can use `mv` also

          [source, bash]
          ----
          $ mkdir /steve/
          $ echo "first line" > test.txt
          $ mv test.txt /steve/
          $ ls /steve/
          test.txt
          ----

          With `mv`, we're changing the path to a file or directory; "moving to a new path".
      - name: 'Moving and renaming files simultaneously: `mv`'
        type: info
        sdbr: null
        ref: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        txt: |
          Since `mv` moves to a different path,
          it can rename the file and move it to a different directory simultaneously.

          [source, bash]
          ----
          $ mkdir /steve/
          $ echo "first line" > test.txt
          $ mv test.txt /steve/line.txt
          $ cd /steve/
          $ ls
          line.txt
          ----
    - name: Deleting filesystem objects
      txt: null
      inst:
      - name: 'Deleting a single file: `rm`'
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: |
          [source, bash]
          ----
          report_Jan.csv
          forecast_Q1.pdf
          ----
        txt: |
          [source, bash]
          ----
          $ rm forecast_Q1.pdf
          $ ls
          report_Jan.csv
          ----
      - name: 'Deleting an empty directory: `rmdir`'
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: |
          .CWD
          [source, bash]
          ----
          client_contact/
            client_list.csv
          reports/
          ----
        txt: |
          `rmdir` removes empty directories
          [source, bash]
          ----
          $ rmdir reports
          $ ls
          client_contact
          ----
          If we try to delete a directory containing objects we get an error.
          [source, bash]
          ----
          $ rmdir client_contact
          ----
          rmdir: failed to remove 'client_contact': Directory not empty
  - name: Command arguments
    txt: |
      null
    modules:
    - name: sad
      txt: null
      inst:
      - name: The many meanings of "command"
        type: info
        sdbr: null
        ref: null
        txt: |
          The use of "command" has been used in different ways.

          * A command as in `echo` (a basic command)
          * A command as in `echo test.txt` (a command with arguments)
          * A command as in `echo test.txr > test.txt` (everything typed before pressing ENTER)

          All three of these are correct.
          While it may seem a problem,
          in practice which of the three meanings of "command" is intended is understood from context.
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: Arguments we've already seen
        type: info
        sdbr: null
        ref: null
        txt: |
          We've seen several cases where a command was used
          with some additional information (which together is also a command):

          * `cd bash-tutorial`
          * `cp test.txt sample.txt`
          * `echo "this is a line"`
          * `mkdir /home/bob/`
          * `mv test.txt test0.txt`

          Instances of that additional information are called _arguments_.
          The arguments we've seen so far are _positional arguments_ and are the simplest type of arguments.
          The meanings of positional arguments are understood based on their location in the arguments.
          For example, with `mv`,

          `mv test.txt test0.txt`

          The first positional argument is always the existing file object and
          the second positional argument is always the new location.
          They cannot be reversed.

          Redirectors (`>`, `>>`) are not arguments. Redirectors are processed by Linux not by commands.
        ccq:
          - type: bool
            txt: question
            ans: 'no'
    - name: Positional arguments
      txt: Most of the Linux commands we've see so far can take positional arguments in ways we haven't used yet.
      inst:
      - name: '`ls` can list multiple directories'
        type: info
        sdbr: null
        ref: |
          .CWD
          [source, bash]
          ----
          bob
            report_Jan.csv
          sue
            forecast_Q1.pdf
          ----
        txt: |
          [source, bash]
          ----
          $ ls bob sue
          bob:
            report_Jan.csv
          sue:
            forecast_Q1.pdf
          ----
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: '`cp` can copy multiple objects to a target'
        type: info
        sdbr: null
        ref: |
          .CWD
          [source, bash]
          ----
          report_Jan.csv
          forecast_Q1.pdf
          sue/
          ----
        txt: |
          [source, bash]
          ----
          $ cp report_Jan.csv forecast_Q1.pdf sue
          $ ls sue
          report_Jan.csv
          forecast_Q1.pdf
          ----
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: '`mkdir` can create multiple directories'
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: null
        txt: |
          [source, bash]
          ----
          $ mkdir bob sue
          $ ls
          bob sue
          ----
      - name: '`mv` can move multiple objects to another directory'
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: |
          .CWD
          [source, bash]
          ----
          report_Jan.csv
          forecast_Q1.pdf
          sue/
          ----
        txt: |
          [source, bash]
          ----
          $ mv report_Jan.csv forecast_Q1.pdf sue
          $ ls sue
          report_Jan.csv
          forecast_Q1.pdf
          ----
      - name: '`rm` can remove multiple file objects'
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: |
          .CWD
          [source, bash]
          ----
          report_Jan.csv
          forecast_Q1.pdf
          ----
        txt: |
          [source, bash]
          ----
          $ rm report_Jan.csv forecast_Q1.pdf
          $ ls
          ----
      - name: '`rmdir` can remove multiple directories'
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: |
          .CWD
          [source, bash]
          ----
          bob
          sue
          ----
        txt: |
          [source, bash]
          ----
          $ rmdir bob sue
          $ ls
          ----
      - name: '`cat` can display multiple files'
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: |
          .CWD
          [source, bash]
          ----
          report_Jan.csv
          forecast_Q1.pdf
          ----
        txt: |
          [source, bash]
          ----
          $ cat report_Jan.txt forecast_Q1.txt
          Jan: 100,000,000
          Q1: 400,000,000
          ----
      - name: '`echo` can display multiple pieces of text'
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: null
        txt: |
          [source, bash]
          ----
          $ echo "a" "b"
          a b
          ----
    - name: Options
      txt: null
      inst:
      - name: 'Option example: `ls -1`'
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: |
          .CWD
          [source,bash]
          ----
          company_brand_book.pdf
          logo_guidelines.pdf
          ----
        txt: |
          An _option_ is an argument of one letter preceded by a dash "-".
          An example of using an option is `-1` used with `ls`.
          `-1` (one-column) instructs `ls` to list directory contents vertically instead of horizontally.
          [source,bash]
          ----
          $ ls
          company_brand_book.pdf logo_guidelines.pdf
          $ ls -1
          company_brand_book.pdf
          logo_guidelines.pdf
          ----
      - name: 'Printing directory contents in reverse: `ls -r`'
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: |
          .CWD
          [source,bash]
          ----
          company_brand_book.pdf
          logo_guidelines.pdf
          ----
        txt: |
          The `-r` argument of `ls` reverses the normal alphabetical order of the output.
          [source,bash]
          ----
          $ ls
          company_brand_book.pdf logo_guidelines.pdf
          $ ls -r
          logo_guidelines.pdf company_brand_book.pdf
          ----
      - name: Using multiple options
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: |
          .CWD
          [source,bash]
          ----
          company_brand_book.pdf
          logo_guidelines.pdf
          ----
        txt: |
          To print `ls` output in one column in reverse order:
          [source,bash]
          ----
          $ ls -1 -r
          logo_guidelines.pdf
          company_brand_book.pdf
          ----
    - name: Using multiple options
      txt: |
        To print `ls` output in a reversed single column, we use `-1` and `-r`.
        [source,bash]
        ----
        company_brand_book.pdf
        logo_guidelines.pdf
        ----

        [source,bash]
        ----
        $ ls -r -1
        logo_guidelines.pdf
        company_brand_book.pdf
        ----
      inst:
      - name: Options can appear in any order
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: |
          .CWD
          [source,bash]
          ----
          company_brand_book.pdf
          logo_guidelines.pdf
          ----
        txt: |
          Options, unlike positional arguments,
          may occur in any order where they are allowed, so `-1 -r` works just like `-r -1`.
          [source,bash]
          ----
          $ ls -r -1
          logo_guidelines.pdf
          company_brand_book.pdf
          $ ls -1 -r
          logo_guidelines.pdf
          company_brand_book.pdf
          ----
      - name: Combining options
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: |
          .CWD
          [source,bash]
          ----
          company_brand_book.pdf
          logo_guidelines.pdf
          ----
        txt: |
          As a shortcut, options can be bundled together, or _combined_.
          [source,bash]
          ----
          $ ls -1r
          logo_guidelines.pdf
          company_brand_book.pdf
          ----
      - name: Using options with positional arguments
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: |
          .CWD
          [source,bash]
          ----
          marketing
            campaigns
              Q1_product_launch.pdf
              summer_promo_plan.pdf
            branding
              logo_guidelines.pdf
              company_brand_book.pdf
          ----
        txt: |
          When CWD is `marketing/campaigns`,
          list the contents of `/marketing/branding/` in a reversed single column.
          [source,bash]
          ----
          $ cd marketing/campaigns
          $ ls -1r marketing/branding
          logo_guidelines.pdf
          company_brand_book.pdf
          ----
          Because `marketing/branding` is a positional argument,

          `ls marketing/branding -1r`

          is invalid.


          Most commands have a specified area where options can occur.
          Within that area options can be in any order.
      - name: How Linux views arguments
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: null
        txt: |
          Consider the following command

          `ls -r -l /home/bob`

          Linux imposes no structure on arguments nor attempts to understand them.
          Linux converts everything after the command to a list and sends the list to the command
          and the command itself is responsible processing arguments.
          So, at program start, `ls` will receive something like this

          `["-r", "-l", "/home/bob/"]`

          Understanding and processing arguments is the responsibility of the command.
          Linux plays no part in it.
          Attempting to standardize,
          most Linux commands follow a certain pattern for their arguments,
          but some Linux commands are rogue and don't follow typical patterns.
  - name: More commands with options
    txt: |
      So far, we have introduced these commands.

      * echo
      * cat
      * ls
      * pwd
      * cd
      * cp
      * mv
      * mkdir
      * rm
      * rmdir

      In addition, we introduced these options:

      * ls: -r, -1,
      * rm: -r, -f

      In this lesson we will explore useful options for many of these commands.
    modules:
    - name: Options for `cp`, `cat`, `mkdir`, and `rm`
      txt: null
      inst:
      - name: 'Copying directory trees: `cp -a`'
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: |
          .CWD
          [source, bash]
          ----
          client_contact
            client_list.csv
          ----
        txt: |
          A quick form of backup is copying a directory and all its contents.
          Let's copy `client_contact`` to another directory in CWD.
          [source, bash]
          ----
          $ cp -a client_contact client_contact_backup
          $ ls
          client_contact client_contact_backup
          $ ls client_contact_backup
          client_list.csv
          ----
      - name: 'Do not overwrite existing file on copy: `cp -n`'
        type: info
        sdbr: null
        ref: |
          .CWD
          [source, bash]
          ----
          password_policy_19.pdf
          password_policy_20.pdf
          ----
        txt: |
          [source, bash]
          ----
          $ cp -n password_policy_19.pdf password_policy_20.pdf
          ----
          In this situation, `password_policy_20.pdf` will remain unchanged.
          `cp` will not provide any notice that the file was not copied.
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: 'Numbering lines: `cat -n`'
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: null
        txt: |
          "Lorem ipsum" is a corrupted Latin text
          that is used when content is unimportant but text needs a placeholder.
          We will use Lorem ipsum for file content for this course.
          [source, bash]
          ----
          lorem.txt
          ----
          [source, bash]
          ----
          cat lorem.txt
          Lorem ipsum dolor sit amet,
          consectetur adipiscing elit,
          sed do eiusmod tempor incididunt
          ut labore et dolore magna aliqua.
          $ cat -n lorem.txt
          1	Lorem ipsum dolor sit amet,
          2	consectetur adipiscing elit,
          3	sed do eiusmod tempor incididunt
          4	ut labore et dolore magna aliqua.
          ----
      - name: 'Create complete paths: `mkdir -p`'
        type: info
        sdbr: null
        ref: null
        txt: |
          When we want to create a directory where more than one level doesn't exist, `mkdir` will fail.
          [source, bash]
          ----
          $ mkdir /marketing/bob
          mkdir: cannot create directory '/marketing/bob': No such file or directory
          $ mkdir -p /marketing/bob
          $ ls
          marketing
          $ ls marketing
          bob
          ----
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: 'Deleting a directory tree: `rm -rf`'
        type: info
        sdbr: null
        ref: |
          .CWD
          [source, bash]
          ----
          sales
            client_contact
              client_list.csv
          ----
        txt: |
          `rm` provides a powerful option set to remove a directory and its contents but be careful using it.
          Its easy to make a mistake and delete important data.
          [source, bash]
          ----
          $ rm -rf sales
          $ ls sales
          ls: cannot access 'sales': No such file or directory
          ----
          `-r`: _recursive_: a fancy way of saying the command will search the entire directory tree
          `-f`: _force_: without this option, `rm` will prompt before deleting every file

          The most dangerous command possible is `rm -rf /`.
          This will delete everything in your filesystem and crash Linux.
          All data will be lost and Linux will require re-installation.
        ccq:
          - type: bool
            txt: question
            ans: 'no'
    - name: More `ls` options
      txt: null
      inst:
      - name: 'List extended object information: `ls -l`'
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: |
          .CWD
          [source, bash]
          ----
          branding
            company_brand_book.pdf
            logo_guidelines.pdf
          ----
        txt: |
          [source, bash]
          ----
          $ ls -l
          -rw-r--r-- 1 bob bob  1049 Feb  8 01:30 company_brand_book.pdf
          -rw-r--r-- 1 bob bob   124 Feb  8 05:46 logo_guidelines.pdf
          ----
          Most of the output can't be understood until later in the course,
          but the file sizes (1049 and 124) and file date and times are provided.
      - name: 'List object information recursively: `ls -R`'
        type: info
        sdbr: null
        ref: |
          .CWD
          [source, bash]
          ----
          security
            password_policy.pdf
            security_audit_report.pdf
          software
            accounting_software_guide.pdf
            crm_tool_manual.pdf
          ----
        txt: |
          [source, bash]
          ----
          $ ls -R
          security
            password_policy.pdf
            security_audit_report.pdf
          software
            accounting_software_guide.pdf
            crm_tool_manual.pdf
          ----
          `ls -r` displays the entire directory tree.
        ccq:
          - type: bool
            txt: question
            ans: 'no'
      - name: 'List objects sorted by time: `ls -t`'
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: null
        txt: |
          `ls -t` changes from the default alphabetical sort order to ordering from most recent to oldest.
          [source, bash]
          ----
          $ ls -l
          -rw-r--r-- 1 kev kev   7777 Feb  2 23:20 slides.py
          -rw-r--r-- 1 kev kev   2334 Jan 29 22:50 reference.txt
          $ ls -lt
          -rw-r--r-- 1 kev kev   2334 Jan 29 22:50 reference.txt
          -rw-r--r-- 1 kev kev   7777 Feb  2 23:20 slides.py
          ----
      - name: 'Listing file objects with markers: `ls -F`'
        type: info
        sdbr: null
        ccq:
          - type: bool
            txt: question
            ans: 'no'
        ref: |
          .CWD
          [source, bash]
          ----
          password_policy.pdf
          security
          ----
        txt: |
          [source, bash]
          ----
          $ ls -F
          password_policy.pdf security/
          ----
          Notice that `security` has `/` after it to indicate a directory.
          `-F` has several other markers that will be explored later.
- name: Making Bash easier to use
  txt: methods to reduce typing effort in Bash
  lessons:
  - name: asdf
    txt: null
    modules:
    - name: Path resolution
      txt: null
      inst:
      - name: Absolute paths
        type: info
        txt: |
          So far, if we wanted to address a filesystem object in a directory that is not CWD,
          we typed out the entire path
          [source, bash]
          ----
          $ pwd
          /it/configuration/
          $ ls /hr/policies/
          leave.txt
          ----
          We are in the /it/configuration/ directory,
          but we wish to see what's in the /hr/policies directory.

          This is called an _absolute path_.
          Absolute paths are always from the perspective of the root directory.
      - name: Relative paths
        type: info
        ref: |
          [source, bash]
          ----
          /departments/marketing
          ----
        txt: |
          Typing put all those absolute paths is a chore.
          As a shortcut, Bash offers _relative paths_ which are from the perspective of the CWD.
          Relative paths are the reason in previous examples we didn't need to add paths
          when working with CWD previously.

          Let's create a directory in CWD and change to it.
          [source, bash]
          ----
          mkdir media
          cd media
          ----
          In both lines we used relative paths. Using absolute paths would require
          [source, bash]
          ----
          mkdir /departments/marketing/media
          cd /departments/marketing/media
          ----
      - name: 'The parent directory reference: `..`'
        type: info
        ref: |
          [source, bash]
          ----
          /departments
            marketing/
            it/
          ----
        txt: |
          The _parent directory reference_, `..`, is a shortcut to the parent directory.
          Since a directory can only have one parent directory,
          the meaning of the _parent directory reference_ is never ambiguous.
          [source, bash]
          ----
          cd marketing
          cd ../it
          ----
          Without the parent directory reference we would have to resort to absolute pathing:
          [source, bash]
          ----
          cd marketing
          cd /departments/it
          ----
          The parent directory reference can be used in series.
          If we are deep in a filesystem,
          `cd ../../../steve` would go up three directory levels and into the "steve" directory.
      - name: 'The current directory reference: `.`'
        type: info
        ref: |
          [source, bash]
          ----
          hr
            report.txt
            policies/
          ----
        txt: |
          There is another directory reference for the current directory, `.`.
          [source, bash]
          ----
          cd policies
          cp /hr/report.txt .
          ----
          Copy report.txt from the hr to CWD.
      - name: Quoting
        type: info
        ref: |
          [source, bash]
          ----
          leave policy.txt
          ----
        txt: |
          Spaces in file object names present a problem because
          spaces are how Bash separates objects as well.
          For example,
          [source, bash]
          ----
          $ cat leave policy.txt
          cat: leave: No such file or directory
          cat: policy.txt: No such file or directory
          ----
          Bash interprets "leave" and "policy.txt" as two separate files.
          To resolve this, we use _quoting_
          [source, bash]
          ----
          $ cat 'leave policy.txt'
          ----
          Bash interprets everything in quotes as a single object name.
    - name: File globbing
      txt: null
      inst:
      - name: wildcards
        type: info
        ref: |
          Wildcards are special characters that represent a set of other characters.
          Using wildcards is called, _file globbing.
        txt: |

      - name: 'Globbing multiple characters with `*`'
        type: info
        ref: |
          [source, bash]
          ----
          income1.txt
          income2.txt
          income1.mp4
          income2.mp4
          ----
        txt: |
          [source, bash]
          ----
          $ ls *.txt
          income1.txt income2.txt
          $ ls *.mp4
          income1.mp4 income2.mp4
          ----
      - name: 'Globbing one character with `?`'
        type: info
        txt: |

      - name: 'Globbing specific characters with []'
        type: info
        ref: |
          [source, bash]
          ----
          income1.txt
          income2.txt
          income1.mp4
          income2.mp4
          ----
        txt: |
          [source, bash]
          ----
          $ ls *[1].txt
          income1.txt income1.mp4
          ----
      - name: 'Globbing ranges with []'
        type: info
        ref: |
          [source, bash]
          ----
          income1.txt
          incomea.txt
          income1.mp4
          incomea.mp4
          ----
        txt: |
          [source, bash]
          ----
          $ ls *[a-z].txt
          incomea.txt incomea.mp4
          ----
          The square brackets accept ranges.
          The ranges are

          * a-z: lowercase letters
          * A-Z: uppercase letters
          * 0-9: numerals

          They can be combined.

          [a-zA-Z0-9] will match any lowercase letter, uppercase letter, or numeral.
      - name: 'Globbing with `!`'
        type: info
        ref: |
          [source, bash]
          ----
          income1.txt
          incomea.txt
          income2.mp4
          incomea.mp4
          ----
        txt: |
          `!` means "not" and selects whatever doesn't meet the pattern.
          [source, bash]
          ----
          $ ls *[!a-z]*.*
          income1.txt income2.mp4
          ----
    - name: Basic command chaining
      txt: null
      inst:
      - name: ';'
        type: info
        txt: |
          _Command chaining_ executes commands in a series.
          [source, bash]
          ----
          mkdir accounting; cd accounting; echo 'INCOME STATEMENT' > income.txt
          ----
          `;` executes all the commands regardless of the failure of previous commands.
          In this case, if `mkdir` fails then `cd` will also fail and
          `echo` will create income.txt in CWD.
      - name: '`&&`'
        type: info
        txt: |

          [source, bash]
          ----
          mkdir accounting && cd accounting && echo 'INCOME STATEMENT' > income.txt
          ----
          If `mkdir` fails then nothing else will execute.
          If `cd` fails then `echo` will not execute.
      - name: '`||`'
        type: info
        txt: |
          `||` only allows the next command to execute if the previous command fails.
          It's often used as a cleanup operation or to provide an option in case of failure.
          [source, bash]
          ----
          mkdir marketing || echo "failed" >> fails.log
          ----
          Attempt to create the directory and if it fails write an entry to a log file.
    - name: Command chaining with pipes
      txt: null
      inst:
      - name: '`|`'
        type: info
        txt: |
          Up until now, commands in a chain didn't affect the operation of other commands in the chain.
          The vertical bar is different: the output of one command is sent as input to the next command.
          This process is called _piping_.
          None of the commands studied so far are good candidates for piping, so we introduce two new commands.
      - name: 'listing processes with `ps`'
        type: info
        txt: |
          A _process_ is a currently executing program.
          The commands we have studied so far are also programs
          but they execute without significant delay.
          Executing `ps` will display significant output.
          Each line is a process.
          [source, bash]
          ----
          $ ps
          PID TTY      STAT   TIME COMMAND
            1 ?        Ss     0:08 /sbin/init splash
            2 ?        S      0:00 [kthreadd]
            3 ?        I<     0:00 [rcu_gp]
            ...
          ----
          The output is the first three of hundreds of lines would appear.
          The only part we are interested in is the final column, 'COMMAND'.
      - name: 'Filtering output with `grep`'
        type: info
        txt: |
          Bash executes continuously, most of the time waiting for input,
          so it will appear as one line in the output of `ps`.
          `grep` is a command that takes as it's input the output of another command and filters it.
          Piping `ps` and `grep`, we can see the line for Bash.
          [source, bash]
          ----
          $ ps|grep bash
            29822 pts/1    Ss     0:00 /usr/bin/bash
          ----
          `grep` filtered out all the output lines of `ps` that didn't include the word `bash`.
          The `bash` executable is typically located in /usr/bin/.
          There may be other lines in the output but they are of no concern.
      - name: The difference between redirection and command chaining
        type: info
        txt: |
          The redirection operators, `>`, and `>>` (there's more that will be introduced later) and
          command chaining, `;`,`&&`, `||`, and `|` look somewhat similar.
          The difference is that
          * redirection always has an operator between a command on the left and a file on the right:
            <command> <operator> <file>
          * command chaining always has commands on both sides of the operator:
            <command> <operator> <command>
    - name: Configuration files
      txt: null
      inst:
      - name: 'Hidden files: `.<filename>`'
        type: info
        ref: |
          [source, bash]
          ----
          visible/
          ----
        txt: |
          A _hidden file_ does not normally appear when executing `ls`.
          A hidden file is made by starting the file's name with `.`.
          [source, bash]
          ----
          $ echo '' > .hidden.txt
          $ ls
          ----
          An empty hidden file was created. `ls` shows the directory as empty.

          The primary reason to use hidden files is to avoid clutter with directory listings.
      - name: 'List hidden files: `ls -a`'
        type: info
        txt: |
          To view hidden files with `ls`, use the `-a` option.
          [source, bash]
          ----
          $ echo '' > .hidden.txt
          $ ls -a
          .hidden.txt
          ----
      - name: 'Configuring Bash startup: `.bashrc`'
        type: info
        txt: |
          `.bashrc` is an example of a _Bash script_ which contains a series of Bash commands to
          automatically execute when a Bash session starts.

          `.bashrc` resides in users' home directories.

          You almost certainly have a default `.bashrc` file for your Linux account.

          A new Bash session can be started within Bash by typing `bash`.
          To perserve it for now, change it's name:
          [source, bash]
          ----
          $ mv .bashrc .bashrc.bu
          $ echo "ls -l" >> .bashrc
          $ bash
          (the listing of you home directory appears)
          $ exit
          $ rm .bashrc
          $ mv .bashrc.bu .bashrc
          ----
          Now, upon starting a new Bash session,
          the listing of your home directory will automatically display.
      - name: ''
        type: info
        txt: |
          A
    - name: Environment variables
      txt: null
      inst:
      - name: 'The current user: `$USER`'
        type: info
        txt: |
          _Environment variables_ (EVs) are named character sequences that are kept in memory.
          Some EVs are provided by Bash, called _builtins_, but you can also define your own.
          The value of an EV can be seen using `echo`.
          When referenced on the command line, an EV is always preceded by `$`.
          One builtin is USER, the current username:
          [source, bash]
          ----
          echo $USER
          <username>
          ----
          <username> will be the username you are logged in as.
      - name: 'Make environment variables available to subprocesses: `export`'
        type: info
        txt: ''
      - name: 'List environment variables: `env`'
        type: info
        txt: ''
      - name: 'Directories to search for executable files: `$PATH`'
        type: info
        txt: |
          A builtin EV is $PATH, which tells Bash which directories to seek for executable commands.
          [source, bash]
          ----
          echo $PATH
          ----
          `/usr/bin/`
          should be in the output,
          which is where
          all the commands
          we have studied so far
          are typically located.
      - name: 'The current working directory: `$PWD`'
        type: info
        txt: |
          Another builtin is $PWD, which is the current working directory.
          [source, bash]
          ----
          $ cd /tom
          $ echo $PWD
          tom
          ----
          `pwd` is essentially a shortcut to `echo $PWD`.
          $PATH is typically set in .bashrc.
      - name: 'Directories to use with `cd`: `$CDPATH`'
        type: info
        txt: |
          $CDPATH is a tremendous timesaving EV that easily switching directories.
          When an absolute path is included in $CDPATH,
          it can be used with `cd` with only the final segment of the path.
          [source, bash]
          ----
          $ cd /
          $ $CDPATH=/home/tom/git
          $ cd git
          $ pwd
          git
          ----
          Once set in $CDPATH, instead of typing out `/home/tom/git` every time, we only need to type `git`.
          $CDPATH is typically set in .bashrc.
      - name: 'Setting environment variables: `=`'
        type: info
        txt: |
          The value of environment variables can be assigned using `=`.
          [source, bash]
          ----
          $ MY_VAL='aValue'
          $ echo $MY_VAL
          aValue
          ----
          The pattern to set an EV is

          <name>=<value>
      - name: 'Environment variable rules'
        type: info
        txt: |
          * Don't use `$` with the variable name on the left side
          * Don't use spaces immediately before or after the equals sign
          * The only valid characters for a EV name are letters, digits, and `_`.
          * If the EV value contains a space, the entire value should be quoted.
          * Don't reassign the Bash builtins that are automatically set.
            This includes $PWD and $USER but not $PATH or $CDPATH.
    - name: Statement completion
      txt: null
      inst:
      - name: 'Statement completion with <TAB> 1'
        type: info
        ref: |
          [source,bash]
          ----
          alphonse.txt
          bella.txt
          ----
        txt: |
          To execute `cat alphonse.txt`
          instead of typing out the filename,
          we can type `cat a <TAB>`.
          Bash will complete the rest of the filename.
      - name: 'Statement completion with <TAB> 2'
        type: info
        ref: |
          [source,bash]
          ----
          alphonse.txt
          albert.txt
          ----
        txt: |
          Bash can only complete what is non-ambiguous.
          In this case, there's two files in the directory
          that both begin with `al`.

          To execute `cat alphonse.txt`,
          we must type
          `cat alp <TAB>`
      - name: 'Statement completion with <TAB> 3'
        type: info
        txt: |
          Statement completion also works with commands and directories.
      - name: 'Obtaining completion suggestions with <TAB> <TAB>'
        type: info
        ref: |
          [source,bash]
          ----
          alphonse.txt
          albert.txt
          ----
        txt: |
          In the event Bash can't resolve
          a file object or command with <TAB>,
          it will do nothing.
          In that case, <TAB><TAB> (pressing TAB twice)
          can show what is available
          based on what is already typed.
          [source,bash]
          ----
          cat a <TAB><TAB>
          alphonse.txt albert.txt
          ----
    - name: Command line editing
      txt: null
      inst:
      - name: ''
        type: info
        txt: |
          Bash allows standard key combinations, or _hotkeys_, for editing the command line that
          you're likely already familiar with from computer use.
          These are listed without examples.

          * <&larr;>, <&rarr;> Move the cursor one character at a time
          * <CTRL-&larr;>, <CTRL-&rarr;> Move the cursor one word at a time
          * <DEL> delete current character
          * <BKSP> delete previous character
          * <HOME> move to beginning of line
          * <END> move to end of line
      - name: 'Cutting text'
        type: info
        txt: |
          The next four hotkeys involve _cutting_ text,
          meaning to

          . remove the text and
          . place it in a clipboard.

          The Bash clipboard is independent of any clipboard provided by a GUI.
          When using a GUI with Bash,
          there will be two clipboards and they cannot share content.
      - name: 'Cut from cursor to beginning of word: `<CTRL-w>`'
        type: info
        txt: |
          A
      - name: 'Cut from cursor to end of word: `<ALT-d>`'
        type: info
        txt: |
          A
      - name: 'Cut from cursor to beginning of line: `<CTRL-u>`'
        type: info
        txt: |
          A
      - name: 'Cut from cursor to end of line: `<CTRL-k>`'
        type: info
        txt: |
          A
      - name: 'Paste: `<CTRL-y>`'
        type: info
        txt: |
          `<CTRL-y>` pastes previously text into the current cursor position.
      - name: 'Lowercase from cursor to end of word: `<ALT-l>`'
        type: info
        txt: |
          A
      - name: 'Uppercase from cursor to end of word: `<Alt-u>`'
        type: info
        txt: |
          A
      - name: 'Transpose characters: `<CTRL-t>`'
        type: info
        txt: |
          A
  - name: Command history
    txt: null
    modules:
      - name: 'History hotkeys'
        txt: ''
        inst:
        - name: ''
          type: info
          txt: |
            A
      - name: History environment variables
        txt: null
        inst:
        - name: HISTCODE
          type: info
          txt: ''
        - name: HISTFILESIZE
          type: info
          txt: ''
        - name: HISTIGNORE
          type: info
          txt: ''
        - name: HISTSIZE
          type: info
          txt: ''
      - name: History modifiers
        txt: null
        inst: []
  - name: Command expansion
    txt: null
    modules:
    - name: tilde
      txt: null
      inst: []
    - name: arithmetic
      txt: null
      inst: []
    - name: brace
      txt: null
      inst: []
    - name: parameter
      txt: null
      inst: []
    - name: command
      txt: null
      inst: []
