= Linux
== Bash
=== Basic commands
==== absolute and relative paths
==== ls
==== file globbing
===== wildcards
====== *
====== ?
====== '[]'
====== !
==== cd
==== pwd
==== file
==== cat
==== ln
==== less
==== rmdir
==== cp—Copy files and directories.
==== mv—Move/rename files and directories.
==== mkdir—Create directories.
==== rm—Remove files and directories.
==== ln—Create hard and symbolic links.
==== grep
==== find
==== chmod
==== ps
==== du
==== df
==== touch
==== kill
==== man
==== wc
==== uniq
==== head
==== tail
==== sort
==== tee
==== echo
==== ''
==== ""
=== Expansion
==== tilde
==== arithmetic
==== brace
==== parameter
==== command
=== Processes
==== ps—Report a snapshot of current processes.
==== top—Display tasks.
==== jobs—List active jobs.
==== bg—Place a job in the background.
==== fg—Place a job in the foreground.
==== kill—Send a signal to a process.
==== killall—Kill processes by name.
==== shutdown—Shut down or reboot the system.
=== User management
==== id—Display user identity.
==== chmod—Change a file’s mode.
==== umask—Set the default file permissions.
==== su—Run a shell as another user.
==== sudo—Execute a command as another user.
==== chown—Change a file’s owner.
==== chgrp—Change a file’s group ownership.
==== passwd—Change a user’s password
=== Environment variables
=== History
==== Modifiers
=== Reserved keywords
[cols="10,90",options="header"]
|===
| Keyword | Explanation

| `!`
| Used for logical negation.

| `{`
| Used to begin a block of code.

| `}`
| Used to end a block of code.

| `case`
| Starts a case conditional structure.

| `do`
| Used in loops to mark the beginning of the loop body.

| `done`
| Marks the end of a loop body.

| `elif`
| Introduces an else-if condition in an if statement.

| `else`
| Introduces the else block in an if statement.

| `esac`
| Ends a case conditional structure.

| `fi`
| Ends an if conditional structure.

| `for`
| Starts a for loop.

| `if`
| Starts an if conditional structure.

| `in`
| Used in for and case structures to introduce the list or pattern.

| `then`
| Introduces the body of an if, elif, or else statement.

| `until`
| Starts an until loop.

| `while`
| Starts a while loop.

| `function`
| Declares a function.

| `select`
| Starts a select loop, useful for creating menus.

| `time`
| Used to measure the time taken by a command to execute.

| `[[`
| Starts an extended test command.

| `]]`
| Ends an extended test command.

| `coproc`
| Starts a co-process.
|===

=== Special characters

[options="header"]
|===
| Character | Template | Name | Example | Explanation

| `>`
| `command > file`
| Redirection
| `echo "Hello" > hello.txt`
| Redirects the output of a command to a file, overwriting the file.

| `>>`
| `command >> file`
| Append
| `echo "World" >> hello.txt`
| Appends the output of a command to a file without overwriting it.

| `<`
| `command < file`
| Input Redirection
| `grep "Hello" < hello.txt`
| Takes the content of a file and uses it as input for the command.

| `|`
| `command1 | command2`
| Pipe
| `cat hello.txt | grep "Hello"`
| Sends the output of one command (command1) to another command (command2) as input.

| `&`
| `command1 & command2`
| Background Execution
| `find / -name hello.txt &`
| Executes `command1` and then `command2` in the background.

| `&&`
| `command1 && command2`
| AND List
| `mkdir new_dir && cd new_dir`
| Executes `command2` only if `command1` completes successfully.

| `||`
| `command1 || command2`
| OR List
| `grep "Hello" file.txt || echo "Not found"`
| Executes `command2` only if `command1` fails.

| `;`
| `command1 ; command2`
| Command Separator
| `cd folder; ls`
| Executes `command1` and then `command2`, regardless of the success of `command1`.

| `$`
| `$variable`
| Variable Expansion
| `echo $HOME`
| Expands to the value of `variable`.

| `$( )`
| `$(command)`
| Command Substitution
| `echo "Today is $(date)"`
| Replaces the command with its output.

| `{ }`
| `{command1; command2;}`
| Command Grouping
| `{ echo "Start"; ls; }`
| Groups multiple commands to be executed together.

| `( )`
| `(command)`
| Subshell
| `(cd temp_folder; ls)`
| Executes `command` in a subshell.

| `*`
| `ls *`
| Wildcard
| `ls *.txt`
| Matches zero or more characters in filenames or patterns.

| `?`
| `ls ?`
| Single Character Wildcard
| `ls ?.txt`
| Matches any single character in filenames or patterns.

| `[ ]`
| `ls [abc]*`
| Character Class
| `ls [a-c].txt`
| Matches any one of the enclosed characters in filenames or patterns.

| `~`
| `cd ~`
| Home Directory
| `cd ~`
| Expands to the user's home directory.

| `#`
| `# comment`
| Comment
| `# This is a comment`
| Marks the line as a comment, ignored during execution.

| `\`
| `echo "Line1 \`
| `Line2"`
| Line Continuation
| `echo "Hello, \`
| `World"`
| Indicates that the command continues on the next line.

| `!`
| `!command`
| Logical NOT
| `! grep "Hello" file`
| Executes `command` and returns true if `command` fails.

| `{}`
| `{cmd1,cmd2}`
| Brace Expansion
| `echo {A,B}.txt`
| Generates arbitrary strings.

| `[]`
| `ls [pattern]`
| Pattern Matching
| `ls [a-c]*`
| Matches files against the provided pattern.

| `~+`
| `cd ~+`
| Current Directory
| `echo ~+`
| Refers to the current working directory.

| `~-`
| `cd ~-`
| Previous Directory
| `echo ~-`
| Refers to the previous working directory.

| `$?`
| `echo $?`
| Exit Status
| `command; echo $?`
| Shows the exit status of the last command.

| `$$`
| `echo $$`
| Process ID
| `echo $$`
| Shows the process ID of the current shell.

| `$!`
| `command & echo $!`
| Last Background PID
| `command & echo $!`
| Shows the PID of the last background command.

| `$0`, `$1`, ..., `$9`, `$#`, `$@`, `$*`
| `script $1`
| Script Arguments
| `echo $1`
| Special parameters holding script arguments.

| `;;`
| `case ... ;;`
| Case Terminator
| `case $var in ... ;; esac`
| Terminates a branch in a case statement.

| `:`
| `:`
| Null Command
| `:`
| A null command that does nothing, used in scripting.

| `' '`
| `echo 'text'`
| Single Quotes
| `echo 'Hello $USER'`
| Preserves the literal value of each character within the quotes.

| `" "`
| `echo "text"`
| Double Quotes
| `echo "Hello $USER"`
| Preserves most of the literal value but allows variable expansion.

| `>&`, `<&`
| `command >& file`
| File Descriptor Duplication
| `command 2>&1`
| Duplicates one file descriptor to another.

| `<()`, `>()`
| `command <(cmd)`
| Process Substitution
| `diff <(cmd1) <(cmd2)`
| Substitutes the output of a command as a file.

| `<<`, `<<-`
| `command << END`
| Here Document
| `cat << EOF > file`
| Redirects the contents to the command until a delimiter.

| `<<<`
| `command <<< "text"`
| Here String
| `grep "text" <<< "search"`
| Redirects a string into a command.

|===


=== Configuration
==== .bashrc
==== .bash_profile
=== Programming

[options="header"]
|===
| Keyword | Explanation

| `!`
| Used for logical negation.

| `{`
| Used to begin a block of code.

| `}`
| Used to end a block of code.

| `case`
| Starts a case conditional structure.

| `do`
| Used in loops to mark the beginning of the loop body.

| `done`
| Marks the end of a loop body.

| `elif`
| Introduces an else-if condition in an if statement.

| `else`
| Introduces the else block in an if statement.

| `esac`
| Ends a case conditional structure.

| `fi`
| Ends an if conditional structure.

| `for`
| Starts a for loop.

| `if`
| Starts an if conditional structure.

| `in`
| Used in for and case structures to introduce the list or pattern.

| `then`
| Introduces the body of an if, elif, or else statement.

| `until`
| Starts an until loop.

| `while`
| Starts a while loop.

| `function`
| Declares a function.

| `select`
| Starts a select loop, useful for creating menus.

| `time`
| Used to measure the time taken by a command to execute.

| `[[`
| Starts an extended test command.

| `]]`
| Ends an extended test command.

| `coproc`
| Starts a co-process.
|===

=== Example Bash script
----
#!/bin/bash

# Using 'function'
function myfunc {
    echo "Function called"
}

# Using 'select', 'in', 'do', 'done', and 'case'
echo "Select a fruit:"
select fruit in apple orange "none of the above"; do
    case $fruit in
        apple) echo "Apple selected"; break ;;
        orange) echo "Orange selected"; break ;;
        "none of the above") break ;;
        *) echo "Please select a number from the list." ;;
    esac
done

# Using 'for', 'in', 'do', and 'done'
for i in 1 2; do
    echo "Loop $i"
done

# Using 'if', 'then', 'else', 'elif', and 'fi'
if [[ $1 -eq 1 ]]; then
    echo "Argument is 1"
elif [[ $1 -eq 2 ]]; then
    echo "Argument is 2"
else
    echo "Argument is not 1 or 2"
fi

# Using 'while' and 'do'
count=0
while [[ $count -lt 3 ]]; do
    echo "Count is $count"
    ((count++))
done

# Using 'until'
until [[ $count -eq 0 ]]; do
    echo "Countdown $count"
    ((count--))
done

# Using '!'
if ! [[ $count -eq 0 ]]; then
    echo "Count is not zero"
fi

# Using '{}'
{
    echo "This is a block of code"
}

# Using 'coproc'
coproc mycoproc { ls; }
cat <&${mycoproc[0]}

# Calling 'function'
myfunc

# Using 'time'
time echo "Timing this echo command"

# End of the script
----

== File system>
=== File types

[cols="1,15,84",options="header"]
|===
| Letter | Type | Description

| `-`
| Regular file
| A standard file that can contain data, text, or program instructions.

| `d`
| Directory
| A file that contains a list of other files and directories.

| `l`
| Symbolic link
| A special file that serves as a reference or pointer to another file or directory, similar to a shortcut.

| `b`
| Block device
| Represents buffered access to hardware devices and allows data to be read and written in blocks (e.g., hard disks, CD-ROM drives).

| `c`
| Character device
| Represents unbuffered, direct access to hardware devices that do not have a block structure (e.g., serial ports, printers).

| `p`
| Named pipe (FIFO)
| Used for inter-process communication, acting as a conduit to allow two processes to communicate.

| `s`
| Socket
| Used for Inter-Process Communication (IPC) to pass data between processes, commonly in networked services.

|===

=== Directory structure
[cols="10,15,75", options="header"]
|===
| Path | Type | Description

|`/`
|root director
|

|`/bin`
|Essential command [[executable|binaries]] that need to be available in [[single-user mode]], including to bring up the system or repair it,<ref>{{Cite web|title=hier(7) - Linux manual page|url=https://man7.org/linux/man-pages/man7/hier.7.html|access-date=2021-01-06|website=man7.org}}</ref> for all users (e.g., [[cat (Unix)|cat]], [[ls]], [[cp (Unix)|cp]]).
|-
|`/boot`
|Files required for booting, including the kernel.
|-

|`/dev`
|[[Device file]]s (e.g., `[[Null device|/dev/null]]</code>, <code>/dev/disk0</code>,  <code>/dev/sda1</code>, <code>/dev/tty</code>, <code>[[%2Fdev%2Frandom]]`).
|-

| `/etc`
| Configuration files
|

| `/home`
| User home directories. Each user except the root user will get one.
|

| `/lib`
| Essential libraries
| for the binaries in `/bin` and `/sbin`.

| `/media`
| removable media mount points
| such as CD-ROMs (appeared in FHS-2.3 in 2004).

| `/mnt`
| Temporarily mounted filesystems
|

| `/opt`
| add-on application software packages
|

| `/proc`
| Virtual filesystem
| providing process and kernel information as files. In Linux, corresponds to a procfs mount.

| `/root`
| root user home directory
|

| `/run`
| Run-time variable data
| Information about the running system since last boot, e.g., logged-in users and running daemons.

| `/sbin`
| Essential system binaries
| e.g., fsck, init, route.

| `/srv`
| Site-specific data
| served by this system, such as data for web servers, FTP servers, and version control systems.

| `/sys`
| Contains information
| about devices, drivers, and some kernel features.

| `/tmp`
| Directory for temporary files
| often not preserved between system reboots.

| `/usr`
| Secondary hierarchy
| for read-only user data; contains the majority of user utilities and applications.

| `/usr/bin`
| Non-essential command binaries
| for all users, not needed in single-user mode.

| `/usr/include`
| Standard include files
| for development and compilation.

| `/usr/lib`
| Libraries
| for the binaries in `/usr/bin` and `/usr/sbin`.

| `/usr/local`
| Tertiary hierarchy for local data
| specific to this host, typically has further subdirectories.

| `/usr/sbin`
| Non-essential system binaries
| such as daemons for various network services.

| `/usr/share`
| Architecture-independent data
| shared data.

| `/var`
| Variable files
| files whose content changes during normal operation, such as logs and temporary e-mail files.

| `/var/cache`
| Application cache data
| locally generated as a result of I/O or calculation.

| `/var/lib`
| State information
| persistent data modified by programs as they run.

| `/var/lock`
| Lock files
| keeping track of resources currently in use.

| `/var/log`
| Log files
| various system logs.

| `/var/mail`
| Mailbox files
| for user emails, sometimes in `/var/spool/mail`.

| `/var/opt`
| Variable data from add-on packages
| stored in `/opt`.

| `/var/run`
| Run-time variable data
| contains system information data since the system was booted.

| `/var/spool`
| Spool for tasks waiting to be processed
| such as print queues and mail queue.

| `/var/tmp`
| Temporary files
| to be preserved between reboots.
|===

== Networking
== Administration
=== Archiving and Backup
==== gzip—Compress or expand files.
==== bzip2—A block sorting file compressor.
==== tar —Tape-archiving utility.
==== zip —Package and compress files.
==== rsync
=== Text processing
cat —Concatenate files and print on the standard output.
sort—Sort lines of text files.
uniq—Report or omit repeated lines.
cut —Remove sections from each line of files.
paste—Merge lines of files.
join—Join lines of two files on a common field.
comm—Compare two sorted files line by line.
diff—Compare files line by line.
patch—Apply a diff file to an original.
tr—Translate or delete characters.
sed —Stream editor for filtering and transforming text.
aspell—Interactive spell checker.
split
csplit
sdiff
=== User and group management
=== Basic software management
=== System monitoring and logs
